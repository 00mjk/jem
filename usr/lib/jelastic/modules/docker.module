#!/bin/bash

# Copyright 2015 Jelastic, Inc.

# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at

# http://www.apache.org/licenses/LICENSE-2.0

# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.



inherit default config vzexec virtuozzo;
include os output add-docker-route;

DESCRIPTION="Setup docker templates into PCS container";
VERSION="1"
DEFAULT_ACTION="Usage";

$PROGRAM 'vzctl';
$PROGRAM 'vzlist';
$PROGRAM 'vzpkg';
$PROGRAM 'docker';
$PROGRAM 'tar';
$PROGRAM 'sed';
$PROGRAM 'awk';
$PROGRAM 'lsof';
$PROGRAM 'rsync';
$PROGRAM 'timeout';
TIMEOUT_SEC=1200

DOCKER_STATIC="/var/lib/jelastic/docker/docker-static.gz"

OS_centos[7]=".centos-7-x86_64";
OS_centos[6]=".centos-6-x86_64";
OS_centos[5]=".centos-5-x86_64";
OS_debian[6]=".debian-6.0-x86_64";
OS_debian[7]=".debian-7.0-x86_64";
OS_debian[8]=".debian-8.0-x86_64";
OS_ubuntu[1204]=".ubuntu-12.04-x86_64";
OS_ubuntu[1210]=".ubuntu-12.04-x86_64";
OS_ubuntu[1304]=".ubuntu-12.04-x86_64";
OS_ubuntu[1310]=".ubuntu-12.04-x86_64";
OS_ubuntu[1404]=".ubuntu-14.04-x86_64";
OS_ubuntu[1410]=".ubuntu-14.04-x86_64";
OS_ubuntu[1504]=".ubuntu-15.04-x86_64";
OS_ubuntu[1510]=".ubuntu-15.10-x86_64";
OS_ubuntu[1604]=".ubuntu-16.04-x86_64";
OS_ubuntu[1610]=".ubuntu-16.04-x86_64";
OS_fedora[18]=".fedora-18-x86_64";
OS_fedora[19]=".fedora-19-x86_64";
OS_fedora[20]=".fedora-20-x86_64";
OS_fedora[21]=".fedora-21-x86_64";
OS_fedora[22]=".fedora-22-x86_64";
OS_fedora[23]=".fedora-23-x86_64";
OS_fedora[24]=".fedora-23-x86_64";
OS_suse[121]=".suse-12.1-x86_64";
OS_suse[122]=".suse-12.2-x86_64";
OS_suse[123]=".suse-12.3-x86_64";
OS_suse[131]=".suse-13.1-x86_64";
OS_suse[132]=".suse-13.2-x86_64";
OS_kali[1]=".debian-7.0-x86_64";
OS_kali[2]=".debian-8.0-x86_64";
OS_alpine[3]=".alpine-3.x-x86_64";

_DOCKER_CONF="/etc/sysconfig/docker" ;
_DOCKER_LIB="/var/lib/docker" ;
_DOCKER_DRIVER="devicemapper/mnt";

DOCKER_CACHE_DIR="/vz/cache/dockers";
DOCKER_="/var/lib/docker/graph/ba5877dc9beca5a0af9521846e79419e98575a11cbfe1ff2ad2e95302cff26bf/json"
DOCKER_AUTH_CONFIG="~/.dockercfg";
DOCKER_REGISTRY="index.docker.io"
DOCKER_IO_FORMAT=""


if [ -z ${var+x} ]; then
    UPDATE_EXCLUDE_DIR_LIST=("/proc" "/dev" "/sys")
fi

RIMAGE_ID=""
_IS_UPDATE=0
_ADD_TO_HOSTS=0

debian_ostemplate=".debian-D-VERSION-x86_64";
ubuntu_ostemplate=".ubuntu-D-VERSION-x86_64";
centos_ostemplate=".centos-D-VERSION-x86_64";

[ ! -d  "$DOCKER_CACHE_DIR" ] && mkdir -p "$DOCKER_CACHE_DIR";

function doUsage() {
    showUsageMessage;
}

function checkParams() {
    local params=($*)
    local result=""
    for p in ${params[*]} ; do
        eval "[[ -z \"\$$p\" ]] && { result=\"$p $result\";}"
    done
    [[ -z "$result" ]] && return 0;
    echo $result;
    return 1;
}

function onModLoadCallback() {
    log "Preload callback";
    local shortopts="c:,n:,v:,u:,U:,P:,M:,C:,H:,I:,R:,L:,e:,a:,V:,T:,f:E:"
    local longopts="ctid:,name:,version:,url:,username:,password:,email:,cmd:,remote-host:,linkip:,remote-port:,local-port:,env:,alias:,volumes:,ostemplate:,format:,entrypoint:,network:,via:,addtohosts"

    local temp=`getopt -o $shortopts -l $longopts -- "$@" 2>/dev/null`;
    [[ $? != 0 ]] && die -q "Terminating...";
    eval set -- "$temp";

    while true ; do
        #uppercase variables added for migration
        #lowercase variables should be removed as soon as it not used in code
        case "$1" in
            -n   | --name )
                shift;
                docker_id=$1;
                DOCKER_ID=$1;
                shift;
                ;;
            -v   | --version )
                shift;
                version=$1;
                DOCKER_TAG=$1;
                shift;
                ;;
            -c   | --ctid )
                shift;
                ctid=$1;
                CTID=$1;
                vzexecSetCTID $CTID
                shift;
                ;;
            -u   | --url )
                shift;
                url=$1;
                URL=$1;
                DOCKER_REGISTRY=$($SED "s@https://\|http://@@g" <<< $1);
                shift;
                ;;
            -U   | --username )
                shift;
                username=$1;
                USERNAME=$1;
                shift;
                ;;
            -P   | --password )
                shift;
                password=$1;
                PASSWORD=$1;
                shift;
                ;;
            -M   | --email )
                shift;
                email=$1;
                shift;
                ;;
            -C   | --cmd )
                shift;
                cmd=$1;
                shift;
                ;;
            -H  | --remote-host )
                shift;
                REMOTE_HOST=$1;
                shift;
                ;;
            -I  | --linkip )
                shift;
                LINK_IP=$1;
                shift;
                ;;
            -R  | --remote-port )
                shift;
                REMOTE_PORT=$1;
                shift;
                ;;
            -L  | --local-port )
                shift;
                LOCAL_PORT=$1;
                shift;
                ;;
            -e   | --env )
                for arg in "$@" ; do
                    [[ "$2" =~  ^- ]] && break;
                    shift;
                    USER_ENV="$USER_ENV $1"
                done
                shift;
                ;;
            -a  | --alias )
                shift;
                ALIAS=${1};
                shift;
                ;;
            -T  | --ostemplate )
                shift;
                OSTEMPLATE=$1;
                shift;
                ;;
            -V  | --volumes )
                shift;
                oldifs=$IFS;
                IFS=';';
                _VOLUMES=(${1});
                IFS='|';
                _VOLUMES=(${_VOLUMES[*]});
                IFS=${oldifs};
                shift;
                ;;
            -f  | --format )
                shift
                DOCKER_IO_FORMAT=$1
                shift
                ;;
            -E  | --entrypoint )
                shift
                docker_entrypoint_p=$1
                shift
                ;;
            --network )
                shift
                ROUTE_NETWORK=$1
                shift
                ;;
            --via )
                shift
                ROUTE_VIA=$1
                shift
                ;;
            --addtohosts )
		_ADD_TO_HOSTS=1;
                shift
                ;;
            --)
                shift;
                break;
                ;;
        esac;
    done;
    for arg do UNKNOWN_ARG+=("$arg") ; done
    [[ -z "$url" ]] && url=$DOCKER_REGISTRY
    $GREP -q  "index.docker.io" <<< $DOCKER_REGISTRY || DOCKER_ID="${DOCKER_REGISTRY}/${DOCKER_ID}"
    [[ ! -z "$DOCKER_TAG" ]] && DOCKER_ID="${DOCKER_ID}:${DOCKER_TAG}"
}

function populateVListFromUnknown() {
    for i in $(seq 0 $((${#UNKNOWN_ARG[@]}-1))); do
        if [ ! -z "${UNKNOWN_ARG[$i]}" ] ; then
            [ ${#_VOLUMES[*]} -gt 0 ] && _VOLUMES=("${_VOLUMES[@]}" "${UNKNOWN_ARG[$i]}") || _VOLUMES=("${UNKNOWN_ARG[$i]}")
        fi
    done
}

function populateAliasFromUnknown() {
   for i in $(seq 0 $((${#UNKNOWN_ARG[@]}-1))); do
      if [ ! -z "${UNKNOWN_ARG[$i]}" ] ; then
         [ ${#_ALIASES[*]} -gt 0 ] && _ALIASES=("${_ALIASES[@]}" "${UNKNOWN_ARG[$i]}") || _ALIASES=("${UNKNOWN_ARG[$i]}")
      fi
   done
}

function prepareCleanContainer(){
    local ctid=$1;
    [[ $1 =~ ^-?[0-9]+$ ]] || { writeJSONResponseErr "result=>4099" "message=>Missing param $1"; exit 1; };

    $VZCTL mount $ctid  >> $ACTIONS_LOG 2>&1 ;
    [ -d "/vz/root/${ctid}/etc/apache2" ] && { rm -rf "/vz/root/${ctid}/etc/apache2" >>$ACTIONS_LOG 2>&1 ; }
    [ -f /vz/root/${ctid}/etc/rc3.d/S*apache2 ] && { rm -f /vz/root/${ctid}/etc/rc[0-9].d/S[0-9][0-9]apache2 >>$ACTIONS_LOG 2>&1 ; }
    [ -d "/vz/root/${ctid}/etc/httpd" ] && { rm -rf "/vz/root/${ctid}/etc/httpd" >>$ACTIONS_LOG 2>&1 ; }
    [ -f /vz/root/${ctid}/etc/rc3.d/S*httpd ] && { rm -f /vz/root/${ctid}/etc/rc[0-9].d/S[0-9][0-9]httpd >>$ACTIONS_LOG 2>&1 ; }
    [ -f "/vz/root/${ctid}/etc/sysconfig/iptables" ] && { rm -rf "/vz/root/${ctid}/etc/sysconfig/iptables" >>$ACTIONS_LOG 2>&1 ; }
}

function retreiveDockerTemplate(){
    local docker_id=$1;
    local docker_id_no_version=$($SED s/:[^:]*$// <<< $docker_id );
    echo "`date +%D.%k:%M:%S.%N`:   $action:$subaction CTID:$CTID - Start pull" >> ${JEM_CALLS_LOG};
    HOME=$DOCKER_TMP_HOME $DOCKER pull $docker_id > /dev/null 2>&1;
    echo "`date +%D.%k:%M:%S.%N`:   $action:$subaction CTID:$CTID - End pull"   >> ${JEM_CALLS_LOG};
    ct_image_id=$($DOCKER create $docker_id 2>/dev/null);
    [[ -z "$ct_image_id" ]] && ct_image_id=$($DOCKER create $docker_id  /bin/bash 2>/dev/null);
    [[ -z "$ct_image_id" ]] && { logoutFromDockerServer; writeJSONResponseErr "result=>4081" "message=>Could not set up docker template!"; exit 1; }
    docker_tarball="${DOCKER_CACHE_DIR}/${ct_image_id}.tar";
    echo "`date +%D.%k:%M:%S.%N`:   $action:$subaction CTID:$CTID - Start export tarbal" >> ${JEM_CALLS_LOG};
    $DOCKER export $ct_image_id > "${docker_tarball}" ;  res=$?
    echo "`date +%D.%k:%M:%S.%N`:   $action:$subaction CTID:$CTID - End export tarbal"   >> ${JEM_CALLS_LOG};
    [[ "$res" -gt 0 ]] && return 1
    echo "$ct_image_id"
    return 0;
}

function loginToDockerServer(){
    local docker_registry_host;
    DOCKER_TMP_HOME=$( mktemp -d /tmp/dockerXXXXXX 2>/dev/null )
    if [ "xindex.docker.io" == "x$DOCKER_REGISTRY" ] ; then
        docker_registry_host=""
    else
        docker_registry_host=$DOCKER_REGISTRY
    fi
    HOME=$DOCKER_TMP_HOME $TIMEOUT $TIMEOUT_SEC $DOCKER login --username="$username" --password="$password" --email="jelastic@jelastic.com" $docker_registry_host >> $ACTIONS_LOG 2>&1 ;

    local retcode=$?;
    if [[ $retcode == 1 ]] ; then
	   writeJSONResponseErr "result=>4095" "message=>Authentication failed";
	   exit 95;
    elif [[ $retcode == 124 || $retcode == 125 || $retcode == 126 || $retcode == 127 ]] ; then
	   writeJSONResponseErr "result=>4089" "message=>The image can't be fetched due to temporary technical issues";
	   exit 89;
    fi
    return 0;
}

function logoutFromDockerServer(){
    if [ "xindex.docker.io" == "x$DOCKER_REGISTRY" ] ; then
        HOME=$DOCKER_TMP_HOME $DOCKER logout 2>&1 >/dev/null ;
    else
        HOME=$DOCKER_TMP_HOME $DOCKER logout $DOCKER_REGISTRY 2>&1 >/dev/null ;
    fi
    [ -d "$DOCKER_TMP_HOME" ] && rm -rf "$DOCKER_TMP_HOME";
}

#function importTarballToContainer(){
#        local tarball="$1";
#        local ctid="$2";
#        [[ -d "/vz/root/${ctid}/" ]] && {  $TAR --overwrite --exclude=dev -xpf $tarball -C "/vz/root/${ctid}/" 2>/dev/null ;  rm $tarball; }
#}

function importFilesToContainer(){
    local tarball="$1";
    local ctid="$2";
    if [ ! -d "/vz/root/${ctid}.tmpfs/" ]
    then
        mkdir "/vz/root/${ctid}.tmpfs/";
    fi
#FIX for ubuntu
    EXCLUDE_LIST=''
    [ "x$DOCKER_OSTEMPLATE" == "xubuntu" ] && { EXCLUDE_LIST="--exclude=rc1.d --exclude=rc2.d--exclude=rc3.d--exclude=rc4.d--exclude=rc5.d --exclude=etc/init" ; }
    if [ -d "/vz/root/${ctid}.tmpfs/" ]
    then
        $TAR --overwrite ${EXCLUDE_LIST} -xpf $tarball -C "/vz/root/${ctid}.tmpfs/" 2>/dev/null ;
        rm $tarball;
        rm -rf "/vz/root/${ctid}.tmpfs/dev";
        $RSYNC -aPq --force  "/vz/root/${ctid}.tmpfs/" "/vz/root/${ctid}/";
        rm -rf "/vz/root/${ctid}.tmpfs/";
        if $GREP -q storage <<< $DOCKER_ID ; then
            rm -rf /vz/root/${ctid}/var/log/*;
            rm -rf "/vz/root/${ctid}/etc/rsyslog.d/50-default.conf";
        fi
    else
        return 1;
    fi
    return 0;
}

function doCleanup(){
    local crontab_file="/var/spool/cron/root";

    [ -f "$crontab_file"  ] && $GREP -q "jem docker" $crontab_file || printf "*/15 * * * *  /usr/bin/jem docker cleanup --all \n \n \n" >> $crontab_file
    ps aux | $GREP -q "jem docker" | $GREP -v "grep" || {
        [ -d  "$DOCKER_CACHE_DIR" ] && rm -rf ${DOCKER_CACHE_DIR}/*;
            $DOCKER rmi $(docker images -q) >/dev/null 2>/dev/null;
            $DOCKER rm $(docker ps -a -q) >/dev/null 2>/dev/null;
    }
}

function parseDockerConfig() {
    local docker_id=$1

    RUN_SCRIPT_PRIMARY=$($DOCKER inspect --format="{{.Config.Cmd}}" $ct_image_id | $SED -e "s/^{\|}$//g" -e "s/^\[//" -e "s/\]$//" -re "s/\s*<no value>\s*//g" -e "s/\s*<nil>\s*//g" );
    DOCKER_WORKINGDIR_PRIMARY=$($DOCKER inspect --format="{{.Config.WorkingDir}}" $ct_image_id );
    ENTRYPOINT_PRIMARY=$($DOCKER inspect --format="{{.Config.Entrypoint}}" $ct_image_id | $SED -e "s/{\|}//g" -e "s/^\[//" -e "s/\]$//" -re "s/\s*<no value>\s*//g" -e "s/\s*<nil>\s*//g" );
    DOCKER_ENV=$($DOCKER inspect --format="{{json .Config.Env }}" $ct_image_id | $SED -e  "s/\[\|\]//g" -re 's|\"\,\"|\n|g' -e 's/\"//g' );
    DOCKER_EXPOSED_PORT=$($DOCKER inspect --format="{{.Config.ExposedPorts }}" $ct_image_id | $SED -re 's/\s+/\n/g;s/[^0-9\n]//g;s/\n/,/g' -e 's/\,\s*$//' );
    RIMAGE_ID=$($DOCKER inspect --format="{{.Id }}" $docker_id | $SED "s/\[\|\]//g");
    DOCKER_USER=$($DOCKER inspect --format="{{.Config.User}}" $docker_id );
    DOCKER_USER=${DOCKER_USER%:*}
    return 0;
}

function getOSTemplateVersion(){
    local ctid=$1;
    local issue_file="/vz/root/${ctid}/etc/issue";
    local release_files="/vz/root/${ctid}/etc/*-release";
#   local version=$($SED 's/[^0-9.]*\([0-9.]*\).*/\1/' $issue_file | $SED 's/.1$\|.2$\|//g' | $SED '/^$/d'); ### second SED is used as a hack for Ubuntu patches
    local version=$($GREP -h VERSION_ID $issue_file | $SED -ne 's/.*=\"\([0-9.]*\).*/\1/;p;n');
    [ -z "$version" ] && {
        version=$($GREP -h VERSION_ID $release_files | $SED -ne 's/.*=\"\([0-9.]*\).*/\1/;p;n');
    }
    [ -z "$version" ] && {
          $GREP -iq "jessie" $issue_file && version="8";
    }

    [ -z "$version" ] && {
          $GREP -iq "jessie" $issue_file && version="8";
    }

    [ -z "$version" ] && {
          $GREP -iq "jessie" $issue_file && version="8";
    }

    $GREP -iq "debian" $issue_file && [ "${#version}" == "1" ] && version="${version}.0"; # for debian support on PCS
    echo $version;
}

function getOSTemplateType(){
        local ctid=$1;
        local version=$($GREP OSTEMPLATE  /vz/private/$ctid/ve.conf | $SED -nre 's/OSTEMPLATE=\".([a-z]*)-.*/\1/;p;n');
        [ ! -z "$version" ] && { echo "$version" ; } || { echo "undefined"; }
        return 0;
}

function detectWorkingDir(){
#    local ctid=$1;
    DOCKER_WORKINGDIR='';
    # [ ! -z "$docker_entrypoint_p" ] DOCKER_WORKINGDIR="$docker_entrypoint_p" && return 0;
    [ ! -z "$DOCKER_WORKINGDIR_PRIMARY" ] && DOCKER_WORKINGDIR=`echo "$DOCKER_WORKINGDIR_PRIMARY" | base64`;
    return 0;
}

function detectEntryPoint(){
#    local ctid=$1;
    DOCKER_ENTRYPOINT='';
    [ ! -z "$docker_entrypoint_p" ] && DOCKER_ENTRYPOINT="$docker_entrypoint_p" && return 0;
    [ ! -z "$ENTRYPOINT_PRIMARY" ] && DOCKER_ENTRYPOINT=`echo $ENTRYPOINT_PRIMARY | base64`;
    return 0;
}

function detectCmd(){
#    local ctid=${1:?"CTID required"}
    RUN_SCRIPT='';
    [ ! -z "$cmd" ] && RUN_SCRIPT="$cmd" && return 0 ;
    [ ! -z "$RUN_SCRIPT_PRIMARY" ] && RUN_SCRIPT=`echo $RUN_SCRIPT_PRIMARY | base64` ;
    return 0 ;
    # RUN_SCRIPT=$(find /vz/root/${ctid}/ -maxdepth 2  -type f \( -name "run.sh" -o -name "start.sh" -o -name "startup.sh" \) | $SED "s/\/vz\/root\/$ctid//g" | base64 );
    # [ -z "$RUN_SCRIPT" -a ! -z "$RUN_SCRIPT_PRIMARY" ] && RUN_SCRIPT=$(base64 <<< "$RUN_SCRIPT_PRIMARY");
}


function getEntryPoint(){
    local ctid=${1:?"CTID required"}
    local jelinit="/vz/root/${ctid}/etc/init.d/jelinit";
    if [ -f "$jelinit" ] ; then
        file=$($GREP ^ENTRYPOINT_CMD= $jelinit | $SED 's/ENTRYPOINT_CMD=\|"//g');
        [ -f "/vz/root/${ctid}/${file}" ] && { cat "/vz/root/${ctid}/${file}";  } || echo $file  ;
    fi
}

function getCmd(){
    local ctid=${1:?"CTID required"}
    local jelinit="/vz/root/${ctid}/etc/init.d/jelinit";
    if [ -f "$jelinit" ] ; then
        file=$($GREP ^RUN_CMD= $jelinit | $SED 's/RUN_CMD=\|"//g');
        [ -z "$file" ] && file=$($GREP ^RUNSCRIPT= $jelinit | $SED 's/RUNSCRIPT=\|"//g');
        [ -f "/vz/root/${ctid}/${file}" ] && { cat "/vz/root/${ctid}/${file}";  } || echo $file  ;
    fi
}


function setCmd(){
#   local ctid=$1;
    local jelf="$1"
#   /vz/root/${ctid}/.jelstart
    local cmd=$2;
    touch $jelf && chmod +x $jelf;
    local dcmd="";
    if [ ! -z "$cmd" ] ; then
        dcmd=$(echo "$cmd" | $SED 's/ //g' | base64 -d)
        if [ "$dcmd" == "NULL" ] ; then
            dcmd=""
        fi
    fi
    echo "$dcmd" > "$jelf"
#    local jelentry="/vz/root/${ctid}/.jelentry"
}

function doGetRunCmd(){
	local cmd=$(getCmd $ctid);
	cmd1=$($SED -re "s/^\[//g" -e "s/\]$//g" -e 's/\//\\\//g' -e 's/\"/\\"/g' <<< $cmd );
	writeJSONResponseOut "result=>0" "cmd=>$cmd1"
}

function doGetEntrypoint(){
	local cmd=$(getEntryPoint $ctid);
	cmd1=$($SED -re "s/^\[//g" -e "s/\]$//g" -e 's/\//\\\//g' -e 's/\"/\\"/g' <<< $cmd );
	writeJSONResponseOut "result=>0" "entrypoint=>$cmd1"
}

function doGetConfig(){
    local cmd=$(getCmd $ctid);
    cmd1=$($SED -re "s/^\[//g" -e "s/\]$//g" -e 's/\//\\\//g' -e 's/\"/\\"/g' <<< $cmd );
    local entPoint=$(getEntryPoint $ctid);
    entPoint1=$($SED -re "s/^\[//g" -e "s/\]$//g" -e 's/\//\\\//g' -e 's/\"/\\"/g' <<< $entPoint );

    local userenvs_config="/vz/root/${ctid}/.jelenv";
    [ ! -f "$userenvs_config" ] && writeJSONResponseOut "result=>0" "env=>" && return 0;
    val='';
    OLD_IFS=$IFS; IFS=$'\n';
    for keyvalue in $(cat $userenvs_config | $SED 's/export//g' )
    do
        key=$($AWK -F "=" '{ print $1 }' <<< $keyvalue);
        value=$($SED -e "s/${key}=//" -e  's/\"/\\\"/g' <<< $keyvalue);
        val="${val}, \"${key}\":\"${value}\" "
    done
    IFS=$OLD_IFS;
    [ -f "$ACTIONS_LOG" ] && rm "$ACTIONS_LOG";
    writeJSONResponseOut "result=>0" "env\":\"{${val#\,} }" "entrypoint=>$entPoint1" "cmd=>$cmd1"  | $SED -re 's/:"\{/:{/' -e 's/\}"[^ ]/},/g';
}

function doSetRunCmd(){
	setCmd "/vz/root/${ctid}/.jelstart" "$cmd";
	writeJSONResponseOut "result=>0" "message=>run command was set"
}

function doSetEntrypoint(){
      setCmd "/vz/root/${ctid}/.jelentry" "$docker_entrypoint_p";
      if [ -f "/vz/root/${ctid}/etc/init.d/jelinit" ] ; then
        if ! $GREP -q ENTRYPOINT_CMD=  "/vz/root/${ctid}/etc/init.d/jelinit"; then
            runsc=$($GREP ^RUNSCRIPT "/vz/root/${ctid}/etc/init.d/jelinit" | $SED 's/RUNSCRIPT=\|"//g')
            $SED -i "/^RUNSCRIPT=/a RUN_CMD=\"$runsc\"\nENTRYPOINT_CMD=\"/.jelentry\"\nRUNSCRIPT=\$($SED ':a;N;$!ba;s/\\\n/ /g' <<< cat \$ENTRYPOINT_CMD \$RUN_CMD  2>/dev/null )\ndir=\$(cat \$WORKINDIR_CMD 2>/dev/null ) && cd $dir 2>/dev/null" "/vz/root/${ctid}/etc/init.d/jelinit"
            $SED -i '0,/RUNSCRIPT/{//d;}' "/vz/root/${ctid}/etc/init.d/jelinit"
        fi
      fi
      writeJSONResponseOut "result=>0" "message=>entrypoint was set"
}

function doGetEnv(){
      local userenvs_config="/vz/root/${ctid}/.jelenv";
      [ ! -f "$userenvs_config" ] && writeJSONResponseOut "result=>0" "env=>" && return 0;
      val='';
      OLD_IFS=$IFS; IFS=$'\n';
      for keyvalue in $(cat $userenvs_config | $SED 's/export//g' )
      do
             key=$($AWK -F "=" '{ print $1 }' <<< $keyvalue);
             value=$($SED -e "s/${key}=//" -e  's/\"/\\\"/g' -e 's/\{/\\\{/g' -e 's/\}/\\\}/g' <<< $keyvalue);
             val="${val},\"${key}\":\"${value}\""
      done
      IFS=$OLD_IFS;
      [ -f "$ACTIONS_LOG" ] && rm "$ACTIONS_LOG";
      writeJSONResponseOut "result=>0" "env\":\"{${val#\,}}" | $SED -e 's/:"{/:{/' -e 's/}\"}/}}/g';

}

function localSetEnv(){
      local userenvs_config="/vz/root/${ctid}/.jelenv";
    for varpair in $USER_ENV
    do
        key=$($AWK -F "=" '{ print $1 }' <<< $varpair);
        if [[ ! ${key} =~ ^[a-zA-Z_]+[a-zA-Z0-9_]* ]]; then
#            writeJSONResponseErr "result=>4096" "message=>Could not set up variable";
            return 1;
        fi;
    done

      echo "" > $userenvs_config;
      for varpair in $USER_ENV
      do
            key=$($AWK -F "=" '{ print $1 }' <<< $varpair);
            value=$(cut -d=  -f2- <<< $varpair | base64 -d);
            echo "${key}=${value}" >> $userenvs_config;
      done
#      writeJSONResponseOut "result=>0" "message=>command completed successfully"
	return 0;
}

function doSetEnv(){
    if ! isContainerRunning ${CTID} ; then
	writeJSONResponseErr "result=>4110" "message=>Can not execute command. Container is not running" ;
	return 1;
    fi
    localSetEnv "$@";
    if [ $? -eq 0 ]; then
	writeJSONResponseOut "result=>0" "message=>command completed successfully"
    else
        writeJSONResponseErr "result=>4096" "message=>Could not set up variable";
    fi

}

function patchProfile(){
    local ctid=$1;
    local global_profile="/vz/root/${ctid}/etc/profile";  ### local because per container, global because for all users in container
    [ -f "$global_profile" ] && $GREP -q "jelenv" "$global_profile" || echo "OLD_IFS=\$IFS; IFS=$'\n'; for env in \$(cat /.jelenv); do eval \"export \$(echo \$env | sed -rne 's/\"/\\\\\"/g;s/([^=]+)=(.*)/\1=\"\2\"/;p')\"; done ; for env in \$(cat /.jelenv); do eval \"export \$(echo \$env | sed -rne 's/\"/\\\\\"/g;s/([^=]+)=(.*)/\1=\"\2\"/;p')\"; done ;  IFS=\$OLD_IFS" >> $global_profile;
}

function patchPCSContainer(){
    local ctid=$1;
    local userenvs_config="/vz/root/${ctid}/.jelenv";
    local ve_config="/vz/private/${ctid}/ve.conf";
    local default_ostemplate=".busybox-jelastic-multiverse-x86_64";
    DOCKER_OSTEMPLATE=$(getOSTemplateType $ctid);
    patchProfile $ctid;
    [ -z "$DOCKER_USER" ] || echo "$DOCKER_USER" > /vz/root/${ctid}/.jeluser
    echo "$DOCKER_ENV" >>  "$userenvs_config";
    echo "DOCKER_EXPOSED_PORT=$DOCKER_EXPOSED_PORT" >> "$userenvs_config";
    $SED -i '/=/!d' "$userenvs_config";
#    [ -f "$userenvs_config" ]  && { sort -u -t "=" -k1,1 "$userenvs_config"  > "${userenvs_config}.old" ; mv  "${userenvs_config}.old"  "${userenvs_config}" ; };
#    [ -s "$userenvs_config" ] && {
#        OLD_IFS=$IFS; IFS=$'\n';
#        for envvar in $(cat "$userenvs_config")
#        do
#            export "$envvar";
#        done
#        IFS=$OLD_IFS
#    }
    if [ -f "$userenvs_config" ] ; then
        ARG_MAX_VAL=$( getconf ARG_MAX 2>/dev/null )
        file_size=$( du -b $userenvs_config | cut  -f 1 )
        [ -z "$ARG_MAX_VAL" ] && ARG_MAX_VAL=2621440 #2.5Mb
        #let "STR_MAX_LENGTH=$ARG_MAX_VAL/16 - 1" ;
        STR_MAX_LENGTH=131072
        if [[ $file_size -ge $ARG_MAX_VAL ]] ; then
            echo "ARG_MAX=$ARG_MAX_VAL file_size=$file_size" >> $ACTIONS_LOG
            return 1;
        else
            sort -u -t "=" -k1,1 "$userenvs_config"  > "${userenvs_config}.old" ; mv  "${userenvs_config}.old"  "${userenvs_config}" ;
            [ -s "$userenvs_config" ] && {
                OLD_IFS=$IFS; IFS=$'\n';
                for envvar in $(cat "$userenvs_config")
                do
                    if [[ "${#envvar}" -le "$STR_MAX_LENGTH" ]] ; then
                        export "$envvar";
                    else
                        echo "`date +%D.%k:%M:%S.%N`:   $action:$subaction CTID:$CTID long variable: ${envvar/=*/}, length: ${#envvar}, max: $STR_MAX_LENGTH " >> ${JEM_CALLS_LOG};
                        $SED -i "/^${envvar/=*/}=/d" $userenvs_config;
                    fi
                done
                IFS=$OLD_IFS
            }
        fi
    fi

    if [ "x$DOCKER_OSTEMPLATE" == "xdebian" -o "x$DOCKER_OSTEMPLATE" == "xubuntu" ]
    then
        # echo -e '#!/bin/bash\nip addr show | $GREP -q venet0:0 && sleep 10 &&  /etc/init.d/jelinit start & \nexit 0;' > /vz/root/${ctid}//etc/network/if-up.d/jelinit;
        # chmod +x /vz/root/${ctid}//etc/network/if-up.d/jelinit 2>>"$JEM_CALLS_LOG"
        touch /vz/root/${ctid}/etc/network/interfaces
    fi
    if [ "x$DOCKER_OSTEMPLATE" == "xcentos" ] ; then
            [ -f /sbin/MAKEDEV ] && /sbin/MAKEDEV -d /vz/root/${CTID}/dev/ -x {p,t}ty{a,p}{0,1,2,3,4,5,6,7,8,9,a,b,c,d,e,f} ;
    fi
    [ -d "/vz/root/${ctid}/etc/init.d" -o  -L "/vz/root/${ctid}/etc/init.d" ] && echo "$DOCKERINIT" > /vz/root/${ctid}/etc/init.d/jelinit;
    chmod +x /vz/root/${ctid}/etc/init.d/jelinit;
    setCmd "/vz/root/${ctid}/.jelstart" "$RUN_SCRIPT"
    setCmd "/vz/root/${ctid}/.jelentry" "$DOCKER_ENTRYPOINT"
    setCmd "/vz/root/${ctid}/.jelworkdir" "$DOCKER_WORKINGDIR"
    [ -f "/vz/root/${ctid}"/run/resolvconf/resolv.conf ] && ln -sf /run/resolvconf/resolv.conf  /vz/root/${ctid}/etc/resolv.conf;
    [ -f "/vz/root/${ctid}/etc/rsyslog.conf" ] && $SED -i "s/^\$ModLoad imklog/#\$ModLoad imklog/g" /vz/root/${ctid}/etc/rsyslog.conf
    ### APP COMMON PATCH ###
    [ ! -d "/vz/root/${ctid}/run/apache2" ] && mkdir -p "/vz/root/${ctid}/run/apache2";
    [ ! -d "/vz/root/${ctid}/run/lock/apache2" ] && mkdir -p "/vz/root/${ctid}/run/lock/apache2";
    rm -f  "/vz/root/${ctid}/etc/systemd/system/multi-user.target.wants/mysql.service" >/dev/null 2>&1
    [ -f /vz/root/${ctid}/etc/rc3.d/S*apache2 ] && { rm -f /vz/root/${ctid}/etc/rc[0-9].d/S[0-9][0-9]apache2 >>$ACTIONS_LOG 2>&1 ; }
    [ -f /vz/root/${ctid}/etc/rc3.d/S*httpd ] && { rm -f /vz/root/${ctid}/etc/rc[0-9].d/S[0-9][0-9]httpd >>$ACTIONS_LOG 2>&1 ; }
    ########################
    return 0;
}

function doRunCommand() {
    if [ -z "$cmd" ] ; then
        writeJSONResponseErr "result=>4085" "message=>command to run required"
        log "docker name required"
        return 1;
    fi
    if [ -z "$CTID" ] ; then
        writeJSONResponseErr "result=>4007" "message=>ctid required"
        log "docker name required"
        return 1;
    fi
    vzexecSetCTID $CTID
    if vzexecRun $cmd ; then
        writeJSONResponseOut "result=>0" "message=>$(vzexecGetLastStdOut)"
    else
        writeJSONResponseErr "result=>4030" "message=>$(vzexecGetLastStdOut)"
    fi
    return 0;
}

function describeFetch() {
    echo "Get remote manifest for specified image";
}

function describeFetchParameters() {
    echo "--name|-n [image name] --url|-u [registry url] --username|-U [username] --password|-P [password] -f|--format [format]";
}

function describeFetchOptions() {
    echo "name    : name of the docker image";
    echo "url     : URL to the docker registry. Default is ${DOCKER_HOST}";
    echo "username: username for login to docker registry";
    echo "password: password for the username"
    echo "format  : format the output using the given go template"
}

function doFetch() {
    local requiredParqams=("DOCKER_ID")
    local msg=$(checkParams ${requiredParqams[@]})
    [[ ! -z "${msg}" ]] && { writeJSONResponseErr "result=>4099" "message=>Missing param $msg" ; return 99; }

    [ ! -z "$USERNAME" ] && [ ! -z "$PASSWORD" ] && loginToDockerServer $CTID >> $ACTIONS_LOG;
    local lDockerOpts=""
    [[ ! -z "${DOCKER_IO_FORMAT}" ]] && { lDockerOpts="--format='"${DOCKER_IO_FORMAT}"'"; }
    manifest=$(
        if [[ ! -z "${lDockerOpts}" ]] ; then
            HOME=$DOCKER_TMP_HOME $DOCKER manifest "$lDockerOpts" $DOCKER_ID 2>&1
        else
            HOME=$DOCKER_TMP_HOME $DOCKER manifest $DOCKER_ID 2>&1
        fi
    );
    ret=$?;
    result=$($SED -n -re '/[Rr]esult/{s/.*[Rr]esult":\s*"?([0-9]+)"?.*/\1/;p}' <<< $manifest )
    outfn="writeJSONResponseOut";
    if [[ $ret -ne "0" ]] ; then
        outfn="writeJSONResponseErr";
    else
        if [[ ! -z "$result" ]] ; then
            outfn="writeJSONResponseErr";
            ret=$result
        fi
    fi
    $outfn "result=>$ret" "manifest=>$manifest" ;
    logoutFromDockerServer
    return $ret
}

function localAddVolume() {
    local requiredParqams=("CTID")
    local msg=$(checkParams ${requiredParqams[@]})
    local new=()
    local old=()
    [[ ! -z "${msg}" ]] && { writeJSONResponseErr "result=>4099" "message=>Missing param $msg" ; return 99; }

    [[ "${#_VOLUMES[@]}" -eq "0" ]] && populateVListFromUnknown

    oldifs=$IFS;IFS=$'\n'
    for i in $(seq 0 $((${#_VOLUMES[*]}-1)) ) ; do
        vp="/vz/root/${CTID}${_VOLUMES[$i]}"
        if [[ ! -d "$vp" ]] ; then
            mkdir -p "$vp" >> $ACTIONS_LOG 2>&1;
            new=(${new[@]} ${_VOLUMES[$i]})
        else
            old=(${old[@]} ${_VOLUMES[$i]})
        fi
    done
    IFS=${oldifs}
#    writeJSONResponseOut "result=>0" "message=>Volumes has been added succesfully" "new=>${new[*]}" "existed=>${old[*]}"
}

function doAddVolume() {
    localAddVolume && writeJSONResponseOut "result=>0" "message=>Volumes has been added succesfully" "new=>${new[*]}" "existed=>${old[*]}";
}

function doMount() {
    local requiredParqams=("CTID")
    local locked=0
    local locked_log="/locked_files.log"
    local msg=$(checkParams ${requiredParqams[@]})
    [[ ! -z "${msg}" ]] && { writeJSONResponseErr "result=>4099" "message=>Missing param $msg" ; return 99; }

    #check for locked files
    vzexecRun "rm ${locked_log}"
    for i in $(seq 0 2 $((${#_VOLUMES[@]} -1)) ) ; do
        lSource=${_VOLUMES[$(($i+1))]}
        vzexecRun "[[ -d \"${lSource}\" ]] && lsof +D \"${lSource}\""
        msg="$(vzexecGetLastStdOut)";
        [[ ! -z "${msg}" ]] && {
                echo "$msg" >> "/vz/root/${CTID}${locked_log}"
            locked=1
        }
    done
    if [[ "${locked}" -gt 0 ]] ; then
                text=$($SED -re 's/\\/\\\\/g;s/"/\\"/g' "/vz/root/${CTID}${locked_log}")
                printf "{\"result\":\"%s\", \"message\":\"%s\",\"out\":\"%s\",\"log\":\"%s\"}\n" "4100" "Some files are locked" "$text" "$locked_log"
        return 1;
    fi

    fstab=$(processMounts )
    vzexecRun "mount -a"
    vzexecRun "rm '${locked_log}'"
    writeJSONResponseOut "result=>0" "message=>Volumes mount succesfully" "fstab=>$fstab"
    return 0;
}

function doUmount() {
    local requiredParqams=("CTID")
    local msg=$(checkParams ${requiredParqams[@]})
    [[ ! -z "${msg}" ]] && { writeJSONResponseErr "result=>4099" "message=>Missing param $msg" ; return 99; }
    for i in $(seq 0 2 $((${#_VOLUMES[@]} -1)) ) ; do
        lSource=${_VOLUMES[$i]}
        lTarget=${_VOLUMES[$(($i+1))]}
        msg=$(doAction storage umount --source "${lSource}" --destination "${lTarget}" --ctid $CTID 2>&1)
        result=$($SED -n -re '/result/{s/.*result":"([0-9]+)".*/\1/;p}' <<< $msg )

        if [[ ${result} -eq 0 ]] ; then
        #parse source string
            eval "$(echo ${lSource} | $SED -rne "s/(([Ll][Oo][Cc][Aa][Ll]|[Nn][Ff][Ss]|[Ww][Ee][Bb][Dd][Aa][Vv]):?(\/){2})?([^:]+):?(.*)/mtype='\2';sourceIP='\4';sourceMount='\5';/g;p")"
            if [[ "${mtype}" == "local" ]] ; then
                [[ ! -z "${sourceIP}" ]] && $RSYNC -aP --force "/vz/root/${CTID}/${sourceIP}" "/vz/root/${CTID}${lTarget}" >> $ACTIONS_LOG 2>&1
            else
                echo "$msg"
                return 1;
            fi
        fi
    done
    writeJSONResponseOut "result=>0" "message=>Volumes ummount succesfully" "fstab=>$fstab"
    return 0;
}

function processMounts() {
    local message
    local fstab
    for i in $(seq 0 2 $((${#_VOLUMES[@]} -1)) ) ; do
        lSource=${_VOLUMES[$i]}
        lTarget=${_VOLUMES[$(($i+1))]}
        msg=$(doAction storage mount --source "${lSource}" --destination "${lTarget}" --ctid $CTID --movedata 1)
        result=$($SED -n -re '/result/{s/.*result":"([0-9]+)".*/\1/;p}' <<< $msg )
        [[ $result -ne 0 ]] && {
            message=$($SED -n -re '/message/{s/.*message":"(.*)"/\1/;p}' <<< $msg)
            log "Fail to mount $lTarget: $message"
        }
        fstab="${fstab}$($SED -n -re '/message/{s/.*"message":"([^"]+)".*/\1/;p}' <<< $msg)\n"
    done
    echo $fstab
    return 0
}

function describeSetup() {
    echo "Setup docker image inside VZ container";
}

function describeSetupParameters() {
    echo "--name|-n 'image name' --url|-u [registry url] --username|-U [username] --password|-P [password] --ctid|-c ctid";
}

function describeSetupOptions() {
    echo "name    : name of the docker image";
    echo "url     : URL to the docker registry. Default is ${DOCKER_HOST}";
    echo "username: username for login to docker registry";
    echo "password: password for the username"
    echo "ctid    : target VZ container"
}

function doSetup(){
    VERBOSE=1
    echo "`date +%D.%k:%M:%S.%N`: $action:$subaction CTID:$CTID  start" >> ${JEM_CALLS_LOG};
    local requiredParqams=("DOCKER_ID" "CTID")
    local msg=$(checkParams ${requiredParqams[@]})
    [[ ! -z "${msg}" ]] && { writeJSONResponseErr "result=>4099" "message=>Missing param $msg" ; return 99; }
    [ ! -z "$USERNAME" ] && [ ! -z "$PASSWORD" ] && loginToDockerServer $CTID #>> $ACTIONS_LOG 2>&1;
    DOCKER_OSTEMPLATE=$(getOSTemplateType $CTID);

    ct_image_id=$(retreiveDockerTemplate "$DOCKER_ID")
    res=$?
    [[ "$res" -gt 0 ]] && return 1;

    dockerTarball="${DOCKER_CACHE_DIR}/${ct_image_id}.tar";
    prepareCleanContainer $CTID  >> $ACTIONS_LOG 2>&1;

    echo "`date +%D.%k:%M:%S.%N`:   $action:$subaction CTID:$CTID - Clean container created" >> ${JEM_CALLS_LOG};
    $VZCTL mount $CTID >> $ACTIONS_LOG 2>&1;

    echo "`date +%D.%k:%M:%S.%N`:   $action:$subaction CTID:$CTID - Container started - or mounted - recheck this step:DEBUG" >> ${JEM_CALLS_LOG};
    importFilesToContainer $dockerTarball $CTID >> $ACTIONS_LOG 2>&1;
    echo "`date +%D.%k:%M:%S.%N`:   $action:$subaction CTID:$CTID - Container data imported" >> ${JEM_CALLS_LOG};
    $GREP -q -E "127.0.0.1\s*localhost.*" "/vz/root/${CTID}/etc/hosts" || echo  "127.0.0.1 localhost.localdomain localhost" >> "/vz/root/${CTID}/etc/hosts"

    parseDockerConfig $DOCKER_ID >> $ACTIONS_LOG 2>&1;
    echo "`date +%D.%k:%M:%S.%N`:   $action:$subaction CTID:$CTID - Config parsed" >> ${JEM_CALLS_LOG};
    detectEntryPoint >> $ACTIONS_LOG 2>&1;
    detectCmd >> $ACTIONS_LOG 2>&1;
    detectWorkingDir >> $ACTIONS_LOG 2>&1;
    echo "`date +%D.%k:%M:%S.%N`:   $action:$subaction CTID:$CTID - Detected entrypoint, workdir, runcmd" >> ${JEM_CALLS_LOG};
    localSetEnv $@ >> $ACTIONS_LOG 2>&1;
    echo "`date +%D.%k:%M:%S.%N`:   $action:$subaction CTID:$CTID - Set env" >> ${JEM_CALLS_LOG};
    patchPCSContainer $CTID >> $ACTIONS_LOG 2>&1;

    vzexecSetCTID $CTID

    localAddVolume >> $ACTIONS_LOG 2>&1;

    if [[ $_IS_UPDATE -eq 1 ]]  ; then
        log "[${CTID}]: restoring files"
        [[ "${#_VOLUMES[@]}" -eq "0" ]] && populateVListFromUnknown
        if [[ -f "/vz/tmp/ct${CTID}.tar" ]] ; then
            unpackFiles $CTID && {
                log "[${CTID}]:  removing tarball /vz/tmp/ct${CTID}.tar"
                rm "/vz/tmp/ct${CTID}.tar"
            }
        fi
    fi

    $VZCTL umount $CTID >> $ACTIONS_LOG 2>&1;
    echo "`date +%D.%k:%M:%S.%N`:   $action:$subaction CTID:$CTID - Umount container" >> ${JEM_CALLS_LOG};
    # JE-25469
    [ "x$DOCKER_OSTEMPLATE" == "xalpine" ] && {
        echo "`date +%D.%k:%M:%S.%N`:   $action:$subaction CTID:$CTID - add tun for alpine" >> ${JEM_CALLS_LOG};
        $VZCTL set ${CTID} --devnodes net/tun:rw --capability net_admin:on --save >> ${JEM_CALLS_LOG} 2>&1 ;
    }
    logoutFromDockerServer;

    $VZCTL start $CTID >> $ACTIONS_LOG 2>&1 || { writeJSONResponseErr "result=>4081" "message=>Could not set up docker template!"; exit 1; }
    echo "`date +%D.%k:%M:%S.%N`:   $action:$subaction CTID:$CTID - Start container" >> ${JEM_CALLS_LOG};

#    vzexecRun "getent passwd \"${DOCKER_USER:-root}\" | cut -d: -f6"
#    myhome=$(vzexecGetLastStdOut)
#    echo "HOME=${myhome}" >> "/vz/root/${CTID}/.jelenv";

    [ -f "$DOCKER_AUTH_CONFIG" ] && rm "$DOCKER_AUTH_CONFIG";
    $VZCTL exec $CTID  mknod --mode=666 /dev/ptmx c 5 2 > /dev/null 2>&1;

    echo "`date +%D.%k:%M:%S.%N`:   $action:$subaction CTID:$CTID " >> ${JEM_CALLS_LOG};

    [ "x$DOCKER_OSTEMPLATE" == "xalpine" ] && {
        [ -e /vz/root/${CTID}/dev/tun ] && chmod a+rw /vz/root/${CTID}/dev/tun ; # JE-25469
        vzexecRun "mkdir /dev/net  >/dev/null 2>/dev/null; mknod /dev/net/tun c 10 200  >/dev/null 2>/dev/null; chmod 0666 /dev/net/tun  >/dev/null 2>/dev/null " ; # JE-25469

        if [ -f "/vz/root/${CTID}/etc/fstab" ]; then
            $GREP -q devpts "/vz/root/${CTID}/etc/fstab" || echo "none /dev/pts devpts rw,gid=5,mode=620 0 0" >> "/vz/root/${CTID}/etc/fstab"
            $GREP -q shm "/vz/root/${CTID}/etc/fstab" || echo "none /dev/shm tmpfs defaults 0 0" >> "/vz/root/${CTID}/etc/fstab"
        fi
        $SED -ire 's/types="noproc"/types="nonfs,noproc"/' "/vz/root/${CTID}/etc/init.d/localmount"
        vzexecRun "rc-update add cron";
    }

    [ "x$DOCKER_OSTEMPLATE" == "xdebian" -o "x$DOCKER_OSTEMPLATE" == "xubuntu"  ] && {
        [ ! -e "/vz/root/${CTID}/dev/tty" ]  && {
            mknod "/vz/root/${CTID}/dev/random" c 1 8 >/dev/null 2>&1;
            mknod "/vz/root/${CTID}/dev/urandom" c 1 9 >/dev/null 2>&1;
            for i in $(seq 1 1 9); do mknod -m 660 "/vz/root/${CTID}/dev/tty$i" c 3 $i >/dev/null 2>&1; done ;
            vzexecRun "chown root:tty /dev/tty*" ;
        }

        echo "`date +%D.%k:%M:%S.%N`:   $action:$subaction CTID:$CTID - TTY created" >> ${JEM_CALLS_LOG};
        $VZCTL exec $CTID "touch /tmp/ttt"
        $VZCTL exec $CTID "chown sshd /tmp/ttt >/dev/null 2>/dev/null  || adduser --quiet --system --no-create-home --home /var/run/sshd --shell /usr/sbin/nologin sshd >/dev/null 2>/dev/null"
        $VZCTL exec $CTID "chgrp ssl-cert /tmp/ttt >/dev/null 2>/dev/null || addgroup --system ssl-cert >/dev/null 2>/dev/null"
        $VZCTL exec $CTID "chgrp postfix /tmp/ttt >/dev/null 2>/dev/null || addgroup --system postfix >/dev/null 2>/dev/null"
        $VZCTL exec $CTID "chgrp postdrop /tmp/ttt >/dev/null 2>/dev/null || addgroup --system postdrop >/dev/null 2>/dev/null"
        $VZCTL exec $CTID "chgrp mlocate /tmp/ttt >/dev/null 2>/dev/null || addgroup --system mlocate >/dev/null 2>/dev/null"
        $VZCTL exec $CTID "chown postfix /tmp/ttt >/dev/null 2>/dev/null || adduser --system --home /var/spool/postfix --no-create-home --disabled-password --ingroup postfix postfix >/dev/null 2>/dev/null"

        tries=10
        while [ "$tries" -gt 0 ]
        do
            if $VZCTL exec $CTID ip a | grep -q 'venet0:0' ; then
                break;
            fi
            sleep 1
            tries=$(($tries-1))
        done
        echo "`date +%D.%k:%M:%S.%N`:   $action:$subaction CTID:$CTID - Network check done" >> ${JEM_CALLS_LOG};
        [ -f "/vz/root/${CTID}/run/resolvconf/resolv.conf" ] && ln -sf /run/resolvconf/resolv.conf  /vz/root/${CTID}/etc/resolv.conf;

        [ -d "/vz/root/${CTID}/etc/network/if-post-down.d" -o  -L "/vz/root/${CTID}/etc/network/if-post-down.d" ] && echo "$DEBIANNETFIX" > "/vz/root/${CTID}/etc/network/if-post-down.d/jelnetfix";
        chmod +x "/vz/root/${CTID}/etc/network/if-post-down.d/jelnetfix";
        [ -f  "/vz/root/${CTID}/etc/init.d/rmnologin" ] && sed -i -re '/.*Required-Start:\s/{s/(.*)\$all(.*)/\1\2/}' "/vz/root/${CTID}/etc/init.d/rmnologin" ;
        [ -f "/vz/root/${CTID}/etc/init.d/ssh" ] &&  sed -i '/chrooted() {/areturn 0' "/vz/root/${CTID}/etc/init.d/ssh";

    }

    if [ -f "$DOCKER_STATIC" ] ; then
        $TAR -xpzf "$DOCKER_STATIC" --skip-old-files -C "/vz/root/${CTID}/" 2>> ${JEM_CALLS_LOG};
        echo "`date +%D.%k:%M:%S.%N`:   $action:$subaction CTID:$CTID - Static unpacked" >> ${JEM_CALLS_LOG};
    else
        echo "`date +%D.%k:%M:%S.%N`:   $action:$subaction CTID:$CTID - Static absent" >> ${JEM_CALLS_LOG};
    fi
    [ "x$DOCKER_OSTEMPLATE" == "xcentos" ] && {
        echo "`date +%D.%k:%M:%S.%N`:   $action:$subaction CTID:$CTID - Centos systemd check" >> ${JEM_CALLS_LOG};
        ct_version=$( $GREP VERSION_ID /vz/root/${CTID}/etc/os-release 2>/dev/null | $SED  -ne 's/.*=\"\([0-9.]*\).*/\1/;p;n' )
        if  [ "x$ct_version" == "x7" ] ; then
            vzexecRun "/etc/init.d/network start 2>/dev/null"
            #rm -f /lib/systemd/system/multi-user.target.wants/*;
            vzexecRun "rpm -q --quiet systemd || { yum --nogpgcheck -y swap -- remove systemd-container systemd-container-libs -- install systemd systemd-libs libgudev1 ; } "
        fi
        echo "`date +%D.%k:%M:%S.%N`:   $action:$subaction CTID:$CTID Centos systemd check done" >> ${JEM_CALLS_LOG};
    }
    vzexecRun "touch /var/log/run.log"
    [ "x$DOCKER_OSTEMPLATE" == "xubuntu"  ] && {
       [ -f "/vz/root/${CTID}/sbin/initctl.distrib" ] && {
        vzexecRun "[ -f /sbin/initctl -a -f /sbin/initctl.distrib ] && { rm -f /sbin/initctl ; dpkg-divert --local --rename --remove /sbin/initctl >/dev/null 2>/dev/null; rm -f /usr/sbin/policy-rc.d; } ";
        vzexecRun "RUNL=$(grep 'env DEFAULT_RUNLEVEL' /etc/init/rc-sysinit.conf 2>/dev/null | cut -d '=' -f 2 2>/dev/null) ; init  ${RUNL:-2}";
       }
    }
    writeJSONResponseOut "result=>0" "message=>Docker template been set up succesfully" "os=>$DOCKER_OSTEMPLATE" "imageid=>$RIMAGE_ID" || { writeJSONResponseErr "result=>4081" "message=>Could not set up docker template!"; return 1; };
    return 0
}

function doRun(){
    local requiredParqams=("CTID")
    local msg=$(checkParams ${requiredParqams[@]})
    [[ ! -z "${msg}" ]] && { writeJSONResponseErr "result=>4099" "message=>Missing param $msg" ; return 1; }
    if ! isContainerRunning ${CTID} ; then
	writeJSONResponseErr "result=>4110" "message=>Can not execute command. Container is not running" ;
	return 1;
    fi
    DOCKER_OSTEMPLATE=$(getOSTemplateType $CTID);
    echo "`date +%D.%k:%M:%S.%N`:   $action:$subaction CTID:$CTID " >> ${JEM_CALLS_LOG};
    vzexecSetCTID $CTID
    vzexecRun "mkdir -p /var/run/lock; touch /run/lock/jelinit.firstrun";
    [ "x$DOCKER_OSTEMPLATE" == "xdebian" -o "x$DOCKER_OSTEMPLATE" == "xubuntu"  ] && {
#         echo -e '#!/bin/bash\nip addr show | grep -q venet0:0 && sleep 10 &&  /etc/init.d/jelinit start & \nexit 0;' > /vz/root/${CTID}/etc/network/if-up.d/jelinit;
#         chmod +x /vz/root/${CTID}/etc/network/if-up.d/jelinit 2>>"$JEM_CALLS_LOG"
        vzexecRun "update-rc.d jelinit defaults 99" ;
        vzexecRun "/bin/systemctl enable jelinit"
        vzexecRun "[ -L /etc/resolv.conf ] && { LC_ALL=C RUN_CANONICALDIR=/run/resolvconf dpkg-reconfigure --default-priority --force resolvconf ; update-rc.d resolvconf defaults; }"
    }
    [ "x$DOCKER_OSTEMPLATE" == "xcentos" -o "x$DOCKER_OSTEMPLATE" == "xfedora" ] && {
        vzexecRun "chkconfig --add jelinit" > /dev/null 2>&1;
    }
    [ "x$DOCKER_OSTEMPLATE" == "xalpine" ] && {
        echo "$ALPINEINIT" > "/vz/root/${CTID}/etc/init.d/openrc-jelinit";
        vzexecRun "chmod a+x /etc/init.d/openrc-jelinit ; rc-update add openrc-jelinit default";
    }
    echo "`date +%D.%k:%M:%S.%N`:   $action:$subaction CTID:$CTID start jelinit" >> ${JEM_CALLS_LOG};
    vzexecRun "/etc/init.d/jelinit start" > /dev/null 2>&1;
    echo "`date +%D.%k:%M:%S.%N`:   $action:$subaction CTID:$CTID end" >> ${JEM_CALLS_LOG};
    writeJSONResponseOut "result=>0" "message=>Docker template been started succesfully" "os=>$DOCKER_OSTEMPLATE" ;#|| { writeJSONResponseErr "result=>4082" "message=>Could not start docker template!" ; return 1; };
    return 0
}

function doAfterCreate(){
    VERBOSE=1
    local requiredParqams=("CTID")
    local msg=$(checkParams ${requiredParqams[@]})
    [[ ! -z "${msg}" ]] && { writeJSONResponseErr "result=>4099" "message=>Missing param $msg" ; return 1; }
    if ! isContainerRunning ${CTID} ; then
	writeJSONResponseErr "result=>4110" "message=>Can not execute command. Container is not running" ;
	return 1;
    fi
    local DOCKER_OSTEMPLATE=$(getOSTemplateType $CTID);
    vzexecSetCTID $CTID
    tries=10
    while [ "$tries" -gt 0 ]
    do
        if $VZCTL exec $CTID ip a | grep -q 'venet0:0' ; then
            break;
        fi
        $VZCTL exec $CTID "/sbin/ifup venet0 >/dev/null 2>&1" ;
        sleep 1
        tries=$(($tries-1))
    done

    local issue_file="/vz/root/${CTID}/etc/issue";
    local release_files="/vz/root/${CTID}/etc/*-release";
    issue_string=$(cat $release_files $issue_file 2>/dev/null);
    OS_ver=$(getOSVersion "$issue_string")
    OS_ver=${OS_ver%%.*}

    [ "x$DOCKER_OSTEMPLATE" == "xubuntu"  ] && {
        echo "`date +%D.%k:%M:%S.%N`:   $action:$subaction CTID:$CTID - Ubuntu - fix resolvconf" >> ${JEM_CALLS_LOG};
        vzexecRun "[ -L /etc/resolv.conf ] && { LC_ALL=C RUN_CANONICALDIR=/run/resolvconf dpkg-reconfigure --default-priority --force resolvconf ; update-rc.d resolvconf defaults; }"

    }
    [ "x$DOCKER_OSTEMPLATE" == "xdebian" -o "x$DOCKER_OSTEMPLATE" == "xubuntu"  ] && {
        echo "`date +%D.%k:%M:%S.%N`:   $action:$subaction CTID:$CTID - Debian OS" >> ${JEM_CALLS_LOG};
        vzexecRun "apt-get update || ip a >> /var/log/jem.log && apt-get update" ;
        echo "`date +%D.%k:%M:%S.%N`:   $action:$subaction CTID:$CTID - apt-get update done" >> ${JEM_CALLS_LOG};
        vzexecRun "DEBIAN_FRONTEND=noninteractive apt-get -o Dpkg::Options::=\"--force-confold\" install -y openssh-server logrotate cron gawk sed curl file iptables-persistent --force-yes" ;
        vzexecRun "update-rc.d cron defaults; /etc/init.d/cron start >/dev/null 2>/dev/null;";
        vzexecRun "update-alternatives --set awk /usr/bin/gawk";
        vzexecRun "sed -i -re '/set\s+-e/d' /usr/share/netfilter-persistent/plugins.d/*-ip*tables"
        vzexecRun " [ -L /etc/resolv.conf ] && { apt-get -o Dpkg::Options::=\"--force-confmiss\" install --reinstall resolvconf -y ; }"

        [ "x$OS_ver" == "x7" ] && {
            vzexecRun "DEBIAN_FRONTEND=noninteractive apt-get -o Dpkg::Options::=\"--force-confold\" install -y nfs-common --force-yes"
        }

        echo "`date +%D.%k:%M:%S.%N`:   $action:$subaction CTID:$CTID - apt-get install done" >> ${JEM_CALLS_LOG};
        [ -d "/vz/root/${CTID}/etc/network/if-post-down.d" -o  -L "/vz/root/${CTID}/etc/network/if-post-down.d" ] && echo "$DEBIANNETFIX" > "/vz/root/${CTID}/etc/network/if-post-down.d/jelnetfix";
        [ -f "/vz/root/${CTID}/etc/init.d/ssh" ] &&  $SED -i '/chrooted() {/areturn 0' "/vz/root/${CTID}/etc/init.d/ssh";
    }

    [ "x$DOCKER_OSTEMPLATE" == "xcentos" -o "x$DOCKER_OSTEMPLATE" == "xfedora" ] && {
        vzexecRun "[ -f '/etc/oracle-release' ] && sed -re 's/.*release\s([0-9]+)\..*/\1/g' /etc/oracle-release > /etc/yum/vars/releasever"
        vzexecRun "grep -q ORACLE /etc/os-release 2>/dev/null && grep VERSION_ID /etc/os-release | sed -nre 's/.*=\"?([0-9]*).*/\1/;p;n' > /etc/yum/vars/releasever"
        echo "`date +%D.%k:%M:%S.%N`:   $action:$subaction CTID:$CTID - Centos OS" >> ${JEM_CALLS_LOG};
        vzexecRun "yum install --nogpgcheck -y openssh-server logrotate gawk sed curl file iptables-services >> /var/log/yum.log 2>&1";
        echo "`date +%D.%k:%M:%S.%N`:   $action:$subaction CTID:$CTID - yum install " >> ${JEM_CALLS_LOG};
        vzexecRun "yum install --nogpgcheck cronie -y ";
        [ "x$OS_ver" == "x6" ] && {
            vzexecRun "yum install --nogpgcheck nfs-utils -y ";
            vzexecRun "chkconfig netfs on";
        }

        echo "`date +%D.%k:%M:%S.%N`:   $action:$subaction CTID:$CTID - yum install update done" >> ${JEM_CALLS_LOG};
        [ "x$OS_ver" == "x7" ] && {
#	    vzexecRun "yum -y reinstall openssh-server"
            vzexecRun "mkdir -p /etc/systemd/system/multi-user.target.wants/; ln -s /usr/lib/systemd/system/sshd.service /etc/systemd/system/multi-user.target.wants/sshd.service";
	    vzexecRun "command -v systemctl >/dev/null 2>/dev/null &&  { systemctl enable crond >/dev/null 2>/dev/null; systemctl start crond; }" ;
	}
        vzexecRun "iptables -F INPUT; iptables -F OUTPUT;  iptables -P INPUT  ACCEPT; iptables -P FORWARD  ACCEPT; service iptables save; systemctl enable iptables"
    }
    [ "x$DOCKER_OSTEMPLATE" == "xalpine" ] && {
        echo "`date +%D.%k:%M:%S.%N`:   $action:$subaction CTID:$CTID - Alpine OS" >> ${JEM_CALLS_LOG};
        vzexecRun "apk update";
        vzexecRun "apk add iptables";
        vzexecRun "apk add curl file alpine-sdk tar wget coreutils grep";
        vzexecRun "apk add -f openssh";
        #replace busybox symlink
        vzexecRun "ln -s /usr/bin/grep /bin/grep -f"
    }

    [ "x$DOCKER_OSTEMPLATE" == "xsuse"  ] && {
        echo "`date +%D.%k:%M:%S.%N`:   $action:$subaction CTID:$CTID - Suse - install openssh-server" >> ${JEM_CALLS_LOG};
        vzexecRun "chkconfig jelinit on &>/dev/null; zypper --quiet --non-interactive install openSSH; chkconfig sshd on &>/dev/null;";
    }

    echo "`date +%D.%k:%M:%S.%N`:   $action:$subaction CTID:$CTID - logrotate configure" >> ${JEM_CALLS_LOG};
    [ -d "/vz/root/${CTID}/etc/logrotate.d" ] && {
        echo "$LOGROTATECONF" > "/vz/root/${CTID}/etc/logrotate.d/jelinit";
        vzctl exec ${CTID} "if [ \$(logrotate 2>&1 | head -n 1 | cut -d' ' -f2 | cut -c 1,3,5 2>/dev/null ) \> "380" ] ; then JLOGROUP=\$(stat -c '%G' /var/log/);grep -qE \"u\s*root\" /etc/logrotate.d/jelinit || sed -i \"/daily/a su root \$JLOGROUP\" /etc/logrotate.d/jelinit; fi"
    }

    echo "`date +%D.%k:%M:%S.%N`:   $action:$subaction CTID:$CTID - ssh configure" >> ${JEM_CALLS_LOG};
    vzexecRun "touch /var/log/run.log"

    [ -f "$sshd_config" ] && {
        $SED -i "/PasswordAuthentication/d" $sshd_config;
        $SED -i "/PermitRootLogin/d" $sshd_config;
        echo "PasswordAuthentication yes" >> $sshd_config;
        echo "PermitRootLogin yes" >> $sshd_config;
    }

    #  fix permissions
    [ -d "/vz/root/${CTID}/etc/ssh" ] && chmod 600 /vz/root/${CTID}/etc/ssh/*key  > /dev/null 2>&1;
    [ -f "/vz/root/${CTID}/etc/init.d/sshd" ] && $VZCTL exec ${CTID} "/etc/init.d/sshd restart" > /dev/null 2>&1;
    [ -f "/vz/root/${CTID}/etc/init.d/ssh" ] && $VZCTL exec ${CTID} "/etc/init.d/ssh restart" > /dev/null 2>&1;
    [ -f "/vz/root/${CTID}/usr/lib/systemd/system/sshd.service" ] && $VZCTL exec ${CTID} "systemctl restart sshd" > /dev/null 2>&1;
    echo "`date +%D.%k:%M:%S.%N`:   $action:$subaction CTID:$CTID - End" >> ${JEM_CALLS_LOG};
    writeJSONResponseOut "result=>0" "message=>Packages installed succesfully" "os=>$DOCKER_OSTEMPLATE";
    return 0;
}

function setCase(){
    local alias_r=$1;
    local resultString="$alias_r";
    if [[ "$alias_r" != "${alias_r^^}" ]] ; then
	resultString=$resultString" ${alias_r^^}";
    fi
    if [[ "$alias_r" != "${alias_r,,}" ]] ; then
	resultString=$resultString" ${alias_r,,}";
    fi
    echo $resultString;
}

function doLink(){
    local ct_hosts="/vz/root/${CTID}/etc/hosts";
    local userenvs_config="/vz/root/${CTID}/.jelenv";

    if ! isContainerRunning ${CTID} ; then
	   writeJSONResponseErr "result=>4110" "message=>Can not execute command. Container is not running" ;
	   return 1;
    fi

    [ -z "$ALIAS" ] &&  { writeJSONResponseErr "result=>4099" "message=>Missing param"; return 99; };
    [ -z "$LINK_IP" ] &&  { writeJSONResponseErr "result=>4099" "message=>Missing param"; return 99; };

    if [[ $_ADD_TO_HOSTS -eq 1 ]] ; then
        $GREP -E -q "\s${_ALIASES}(\s|$)" $ct_hosts || echo  "$LINK_IP $(setCase ${ALIAS})"  >> $ct_hosts ;
    else
        for varpair in $USER_ENV ; do
            key=$($AWK -F "=" '{ print $1 }' <<< $varpair);
            value=$(cut -d=  -f2- <<< $varpair | base64 -d);
            $GREP -q "${ALIAS^^}_${key}=${value}" $userenvs_config || echo "${ALIAS^^}_${key}=${value}" >> $userenvs_config;
            local old_value="${ALIAS^^}_${key}";
            $SED -i "/^${old_value}=/d" $userenvs_config;
            echo "${ALIAS^^}_${key}=${value}" >> $userenvs_config;
            local old_valueEnv="${ALIAS^^}_ENV_${key}";
            $SED -i "/^${old_valueEnv}=/d" $userenvs_config;
            echo "${ALIAS^^}_ENV_${key}=${value}" >> $userenvs_config;

            [ "$key" == "DOCKER_EXPOSED_PORT" ] && {
                OLD_IFS=$IFS
                IFS=,
                a_value=($value)

                number_of_elements=${#a_value[@]}
                index=0
                while [ "$index" -lt "$number_of_elements" ] ; do
                    DOCKER_EXPOSED_PORT="${a_value[$index]}";
                    echo "${ALIAS^^}_PORT_${DOCKER_EXPOSED_PORT}_TCP=tcp://${LINK_IP}:${DOCKER_EXPOSED_PORT}" >>  "$userenvs_config";
                    echo "${ALIAS^^}_PORT_${DOCKER_EXPOSED_PORT}_TCP_PORT=${DOCKER_EXPOSED_PORT}" >>  "$userenvs_config";
                    echo "${ALIAS^^}_PORT_${DOCKER_EXPOSED_PORT}_TCP_ADDR=${LINK_IP}" >> "$userenvs_config";
                    echo "${ALIAS^^}_PORT_${DOCKER_EXPOSED_PORT}_TCP_PROTO=tcp" >> "$userenvs_config";
                    echo "${ALIAS^^}_HOST=$LINK_IP" >> "$userenvs_config";
                    echo "${ALIAS^^}_PORT=$DOCKER_EXPOSED_PORT" >> "$userenvs_config";
                    let "index += 1"
                done

                IFS=$OLD_IFS
            }
        done
    fi
    writeJSONResponseOut "result=>0" "message=>containers linked succesfully"
    return 0
}

function describeTags() {
    echo "Get remote tags for specified image";
}

function describeTagsParameters() {
    echo "--name|-n [image name] --url|-u [registry url] --username|-U [username] --password|-P [password]";
}

function describeTagsOptions() {
    echo "name    : name of the docker image";
    echo "url     : URL to the docker registry. Default is ${DOCKER_HOST}";
    echo "username: username for login to docker registry";
    echo "password: password for login"
}

function doTags() {
    local requiredParqams=("DOCKER_ID")
    local msg=$(checkParams ${requiredParqams[@]}) message result tags
    [[ ! -z "${msg}" ]] && { writeJSONResponseErr "result=>4099" "message=>Missing param $msg" ; return 99; }

    [ ! -z "$USERNAME" ] && [ ! -z "$PASSWORD" ] && loginToDockerServer $CTID
    msg=$(HOME=$DOCKER_TMP_HOME $DOCKER tags "$DOCKER_ID" 2>&1 | $SED -re 's/\{"tags":(.*)\}/\1/g' -e 's/\r//' )
    [ "x$msg" == "xnull" ] &&  { writeJSONResponseErr "result=>4098" "message=>Image not found. Please double-check your entries."; return 1 ; }
    result=$($SED -n -re '/[Rr]esult/{s/.*[Rr]esult":\s*"?([0-9]+)"?.*/\1/;p}' <<< $msg )
#    result=$?
    logoutFromDockerServer;

    if [[ "${result:-0}" -gt 0 ]] ; then
        message="Error get tags: $($SED -re 's/([^\])\"/\1\\"/g' <<< ${msg} )"
        writeJSONResponseErr "result=>$result" "message=>${message}"
        return 1
    else
        tags="$msg"
        echo "{\"result\":\"0\",\"message\":\"complete\",\"tags\":${tags}}"
    fi
    return 0
}

function doUnlink(){
    if ! isContainerRunning ${CTID} ; then
	   writeJSONResponseErr "result=>4110" "message=>Can not execute command. Container is not running" ;
	   return 1;
    fi

    local ct_hosts="/vz/root/${ctid}/etc/hosts";
    local userenvs_config="/vz/root/${ctid}/.jelenv";
    $SED -i "/\s${ALIAS}\(\s\|$\)/Id" $ct_hosts;
    for varpair in $USER_ENV
    do
        key=$($AWK -F "=" '{ print $1 }' <<< $varpair);
        value=$(cut -d=  -f2- <<< $varpair | base64 -d);
        $SED -i "/^${ALIAS^^}_/d" $userenvs_config;
    done
    writeJSONResponseOut "result=>0" "message=>containers unlinked succesfully"
    return 0
}

function doRelink(){
    doUnlink "$@" >> $ACTIONS_LOG 2>&1;
    doLink "$@" >> $ACTIONS_LOG 2>&1;
    writeJSONResponseOut "result=>0" "message=>containers relinked succesfully"
    return 0
}

function doAddAlias(){
    [ -z "$CTID" ] &&  { writeJSONResponseErr "result=>4099" "message=>Missing param"; return 99; };
    if isContainerRunning ${CTID} ; then
        populateAliasFromUnknown
        local ct_hosts="/vz/root/${CTID}/etc/hosts";
        for i in $(seq 0 $((${#_ALIASES[*]}-1)) ) ; do
            $GREP -E -q "\s${_ALIASES[$i]##*:}(\s|$)" $ct_hosts || echo  "${_ALIASES[$i]%%:*} $(setCase ${_ALIASES[$i]##*:})" >> $ct_hosts ;
        done
        writeJSONResponseOut "result=>0" "message=>Alias added succesfully"
    else
        writeJSONResponseErr "result=>4110" "message=>Can not execute command. Container is not running" ;
        return 1;
    fi
}

function doRemoveAlias(){
	[ -z "$CTID" ] &&  { writeJSONResponseErr "result=>4099" "message=>Missing param"; return 99; };
	[ -z "$ALIAS" ] &&  { writeJSONResponseErr "result=>4099" "message=>Missing param"; return 99; };
	local ct_hosts="/vz/root/${CTID}/etc/hosts";
	$SED -i -re "/\s${ALIAS}(\s|\$)/Id" $ct_hosts;
	writeJSONResponseOut "result=>0" "message=>Alias added succesfully"
}

function doReplaceAlias(){
   [ -z "$CTID" ] &&  { writeJSONResponseErr "result=>4099" "message=>Missing param"; return 99; };
   if isContainerRunning ${CTID} ; then
      local ct_hosts="/vz/root/${CTID}/etc/hosts";
      populateAliasFromUnknown
      local ct_hosts="/vz/root/${CTID}/etc/hosts";
      for i in $(seq 0 $((${#_ALIASES[*]}-1)) ) ; do
         $SED -i -re "s/^\s*([0-9]{1,3}.){3}[0-9]{1,3}\s*(.*${_ALIASES[$i]##*:}.*)/${_ALIASES[$i]%%:*} \2/" $ct_hosts ;
      done
      writeJSONResponseOut "result=>0" "message=>Alias replaced succesfully" ;
   else
      writeJSONResponseErr "result=>4110" "message=>Can not execute command. Container is not running" ;
      return 1;
   fi
}

function dogetPCSTemplate(){
    local requiredParqams=("DOCKER_ID")
    local msg=$(checkParams ${requiredParqams[@]})
    [[ ! -z "$USERNAME" ]] && [[ ! -z "$PASSWORD" ]] && loginToDockerServer $CTID #>> $ACTIONS_LOG 2>&1;
    calldocker=$(HOME=$DOCKER_TMP_HOME $TIMEOUT $TIMEOUT_SEC $DOCKER baseid --format "{{.TopCachedID}}" $DOCKER_ID 2>&1) ;
    local retCode=$?;
    if [[ $retCode != 0 ]] ; then
        if [[ $retCode == 124 || $retcode == 125 || $retcode == 126 || $retcode == 127 ]] ; then
            writeJSONResponseErr "result=>4089" "message=>The image can't be fetched due to temporary technical issues";
            exit 89;
        fi
        writeJSONResponseErr "result=>4098" "message=>Image not found. Please double-check your entries." ;
        return 98;
    fi
    DOCKER_IMAGE_HASH=$($SED -re 's/.*:\s?\"([a-z0-9]*)\"?.*/\1/' <<< $calldocker) ;
    [ -z "$DOCKER_IMAGE_HASH" ] && {
        writeJSONResponseErr "result=>4098" "message=>Image not found. Please double-check your entries." ; return 98;
    }

    $DOCKER mount $DOCKER_IMAGE_HASH 2>/dev/null >/dev/null

    logoutFromDockerServer;
    _DOCKER_PATH="${_DOCKER_LIB}/${_DOCKER_DRIVER}/$DOCKER_IMAGE_HASH/rootfs"

    if [ -f "${_DOCKER_LIB}/${_DOCKER_DRIVER}/$DOCKER_IMAGE_HASH/id" ] ; then
        issue_file="${_DOCKER_PATH}/etc/issue";
        release_files="${_DOCKER_PATH}/etc/*-release";
        OS_version="";
        _OS="";

        issue_string=$(cat $release_files $issue_file    2>/dev/null);
        OS_version=$($GREP -h VERSION_ID <<< "$issue_string" 2>/dev/null | $SED -nre 's/.*=\"?([0-9.]*).*/\1/;p;n');
        if [ -z "$OS_version" ] ; then
            OS_version=$($GREP -h DISTRIB_RELEASE <<< "$issue_string" 2>/dev/null | $SED -nre 's/.*=\s?\"?([0-9.]*).*/\1/;p;n');
            if [ -z "$OS_version" ] ; then
                if $GREP -hqi "jessie" <<< "$issue_string" 2>/dev/null ; then
                    OS_version="8";
                elif [ -f "${_DOCKER_PATH}/etc/SuSE-brand" ] ; then
                    OS_version=$($GREP "VERSION" ${_DOCKER_PATH}/etc/SuSE-brand | $SED -nre 's/.*=\s?\"?([0-9.]*).*/\1/;p;n');
                    _OS="suse";
                elif [ -z "$OS_version" ] ; then
                    # for  devopsil/puppet
                    OS_version=$($GREP -m 1 -h "CentOS release" <<< "$issue_string" 2>/dev/null | $SED -nre 's/[a-zA-Z ]*\s([0-9.]*).*/\1/;p;n');
                fi
                if [ -z "$OS_version" ] ; then
                    OS_version=$($GREP -m 1 -h "Debian" <<< "$issue_string" 2>/dev/null | $SED -nre 's/[a-zA-Z\/ ]*\s([0-9.]*).*/\1/;p;n');
                fi
                if [ -z "$OS_version" ] ; then
                    OS_version=$($GREP -m 1 -h "Alpine" <<< "$issue_string" 2>/dev/null | $SED -nre 's/[a-zA-Z\/ ]*\s([0-9]*).*/\1/;p;n');
                    $GREP -q "Alpine" <<< "$issue_string" && OS_version=3;
                fi
                if [ -z "$OS_version" ] ; then
                     #Oracle Linux Server release 6.6
                     OS_version=$($GREP -m 1 -h "release" <<< "$issue_string" 2>/dev/null | $SED -nre 's/[a-zA-Z ]*\s([0-9.]*).*/\1/;p;n');
                fi
            fi
        fi
        $DOCKER umount $DOCKER_IMAGE_HASH 2>/dev/null >/dev/null

        [ -z "$_OS" ] && $GREP -iq "kali" <<< $issue_string && _OS="kali"
        [ -z "$_OS" ] && $GREP -iq "ubuntu\|mint" <<< $issue_string && _OS="ubuntu"
        [ -z "$_OS" ] && $GREP -iq "debian" <<< $issue_string && _OS="debian"
        [ -z "$_OS" ] && $GREP -iq "centos" <<< $issue_string && _OS="centos"
        [ -z "$_OS" ] && $GREP -iq "Oracle Linux Server" <<< $issue_string && _OS="centos"
        [ -z "$_OS" ] && $GREP -iq "fedora" <<< $issue_string && _OS="fedora"
        [ -z "$_OS" ] && $GREP -iq "redhat" <<< $issue_string && _OS="centos"
        [ -z "$_OS" ] && $GREP -iq "suse" <<< $issue_string && _OS="suse"
        [ -z "$_OS" ] && $GREP -iq "alpine" <<< $issue_string && _OS="alpine"


        # echo "undefined" && return 0;
        [ "x$_OS" == "xdebian" -o "x$_OS" == "xsuse"  ] && [ "${#OS_version}" == "1" ] && OS_version="${OS_version}.0 "; # for debian support on PCS

        if [ -z "$_OS" -a -z "$OS_version" ]; then
    	    echo "Detected OS: $_OS ; Version: $OS_version" >> $ACTIONS_LOG
            writeJSONResponseErr "result=>4097" "message=>The selected image is based on non-supported OS template"; return 97;
        else
            [ "x$_OS" == "xubuntu" -o "x$_OS" == "xsuse" ] && { OSTPL=OS_$_OS[${OS_version//./}] ; } || { OSTPL=OS_$_OS[${OS_version%%.*}] ;}
            [ -z "${!OSTPL}" ] && {
        	echo "Detected OS: $_OS ; Version: $OS_version" >> $ACTIONS_LOG
                writeJSONResponseErr "result=>4097" "message=>The selected image is based on non-supported OS template"; return 97;
            }||{
                writeJSONResponseOut "result=>0" "message=>Ok" "os=>${!OSTPL}" "detectedOs=>${_OS}-${OS_version}" ;
            }
        fi
    else
        $DOCKER umount $DOCKER_IMAGE_HASH 2>/dev/null >/dev/null
        writeJSONResponseErr "result=>4097" "message=>The selected image is based on non-supported OS template" ; return 97;
    fi
}

function packFiles() {
    local lctid=${1:=$CTID}
    local vp=()

    [[ ${#_VOLUMES[@]} -eq 0 ]] && return 0 # Nothing to do

    #make absolute path
    #TODO: add checks for prefixes (local, nfs etc)
    for i in $(seq 0 $((${#_VOLUMES[*]}-1)) ) ; do
        vp[$i]="/vz/root/${lctid}${_VOLUMES[$i]}"
        if [[ ! -d "${vp[$i]}" ]] ; then
            mkdir -p "${vp[$i]}" >> $ACTIONS_LOG 2>&1;
        fi
    done

    local excl_list=""
    for i in "${UPDATE_EXCLUDE_DIR_LIST[@]}" ; do
        excl_list="$excl_list --exclude '/vz/root/${lctid}${i}'"
    done

    log "[${lctid}] Packing files for $lctid"
    log "[${lctid}]   $TAR -cPf \"/vz/tmp/ct${lctid}.tar\" $excl_list \"${vp[@]}\""
    msg=$($TAR -cPf "/vz/tmp/ct${lctid}.tar" $excl_list "${vp[@]}" 2>&1)
    res=$?
    if [[ $res -gt 0 ]] ; then
        log "[${lctid}] Error saving files to: /vz/tmp/ct${lctid}.tar"
        return 1
    fi
    return 0
}

function unpackFiles() {
    local lctid=${1:=$CTID}

    #make absolute path
    #TODO: add checks for prefixes (local, nfs etc)
    OIFS=$IFS; IFS=$'\n'
    for i in $(seq 0 $((${#_VOLUMES[*]}-1)) ) ; do
        if [[ ! -d "/vz/root/${lctid}${_VOLUMES[$i]}" ]] ; then
            mkdir -p "/vz/root/${lctid}${_VOLUMES[$i]}" >> $ACTIONS_LOG 2>&1;
        fi
    done
    IFS=$OIFS

    msg=$($TAR -xPpf "/vz/tmp/ct${lctid}.tar" 2>&1)
    res=$?
    if [[ $res -gt 0 ]] ; then
        log "[${lctid}] Error restoring files from: /vz/tmp/ct${lctid}.tar"
        return 1
    fi
    return 0
}

function doUpdate() {
    local f_pswd f_shadow f_group f_akeys f_akeys2 f_hosts f_exports f_fstab
    local is_server=0
    local is_client=0
    local exportedDirs

    if [ -z "$CTID" ] ; then
        writeJSONResponseErr "result=>4007" "message=>ctid required"
        log "ctid required"
        return 1;
    fi
    if [ -z "$OSTEMPLATE" ] ; then
        writeJSONResponseErr "result=>4086" "message=>ostemplate required"
        log "ostemplate required"
        return 1;
    fi

    vzIsContainerExists $CTID || { writeJSONResponseErr "result=>4003" "message=>ctid $CTID not found"; return 1; }
    _IS_UPDATE=1

    log "Stopping CTID ${CTID}"
    $VZCTL stop $CTID >> $ACTIONS_LOG 2>&1;
    $VZCTL mount $CTID >> $ACTIONS_LOG 2>&1;

    log "saving old files"
    if [[ -e "/vz/root/${CTID}/etc/exports" ]] ; then
        f_exports=$(cat "/vz/root/${CTID}/etc/exports")
        is_server=1
    fi
    if $GREP -qP "\s+nfs(3|4)?\s+" "/vz/root/${CTID}/etc/fstab" ; then
        f_fstab=$($GREP -P "\s+nfs(3|4)?\s+" "/vz/root/${CTID}/etc/fstab")
        is_client=1
    fi
    f_pswd=$(cat "/vz/root/${CTID}/etc/passwd")
    f_shadow=$(cat "/vz/root/${CTID}/etc/shadow")
    f_group=$(cat "/vz/root/${CTID}/etc/group")
    f_hosts=$(cat "/vz/root/${CTID}/etc/hosts")
    f_iptables=$([ -f "/vz/root/${CTID}/etc/iptables/rules.v4" ] && cat "/vz/root/${CTID}/etc/iptables/rules.v4")
    f_akeys=$( [[ -f "/vz/root/${CTID}/root/.ssh/authorized_keys" ]] && cat "/vz/root/${CTID}/root/.ssh/authorized_keys" )
    f_akeys2=$( [[ -f "/vz/root/${CTID}/root/.ssh/authorized_keys2" ]] && cat "/vz/root/${CTID}/root/.ssh/authorized_keys2" )

    log "Saving user data for: ${CTID}"
    [[ "${#_VOLUMES[@]}" -eq "0" ]] && populateVListFromUnknown
    [[ "${is_server}" -gt "0" ]] && {
        OIFS=$IFS;IFS=$'\n'
        exportedDirs=($(awk '{print $1}' "/vz/root/${CTID}/etc/exports" | uniq))
        IFS=$OIFS
    }
    packFiles $CTID  || {
        writeJSONResponseErr "result=>4004" "message=>can not save user files";
        $VZCTL start $CTID
        return 1;
    }
    $VZCTL umount $CTID >> $ACTIONS_LOG 2>&1;

    log "Replacing OSTEMPLATE with ${OSTEMPLATE}"
    $SED -i -re "/OSTEMPLATE=/{s/=\".*\"/=\"${OSTEMPLATE}\"/g}" "/vz/private/${CTID}/ve.conf" >> $ACTIONS_LOG 2>&1;

    log "Reinstalling ctid ${CTID}"
    $VZCTL reinstall ${CTID} --skipbackup >> $ACTIONS_LOG 2>&1;
    $VZCTL mount ${CTID} >> $ACTIONS_LOG 2>&1;
    doSetup

    if [ "${is_server}" -gt 0 -o "${is_client}" -gt 0 ] ; then
        doAfterCreate >> $ACTIONS_LOG 2>&1;
        for f in "${exportedDirs[@]}" ; do
            mkdir -p "/vz/root/${CTID}${f}"
        done
    fi

    echo -e "$f_pswd" > "/vz/root/${CTID}/etc/passwd"
    echo -e "$f_shadow" > "/vz/root/${CTID}/etc/shadow"
    [[ ! -z "$f_iptables" ]] && {
        [ ! -d "/vz/root/${CTID}/etc/iptables" ] && mkdir "/vz/root/${CTID}/etc/iptables"
        echo -e "$f_iptables" > "/vz/root/${CTID}/etc/iptables/rules.v4"
    }
    echo -e "$f_group" > "/vz/root/${CTID}/etc/group"
    echo -e "$f_hosts" > "/vz/root/${CTID}/etc/hosts"

    [[ "${is_server}" -gt "0" ]] && {
        echo -e "$f_exports" >> "/vz/root/${CTID}/etc/exports"
        vzexecRun "update-rc.d -f iptables-persistent remove && update-rc.d  iptables-persistent defaults && service iptables-persistent start"
        out=$(/usr/bin/jem auth setupUtils --ctid ${CTID} ; /usr/bin/jem auth restart --ctid ${CTID} )
        log $out
    }

    [[ "${is_client}" -gt "0" ]] && {
        echo -e "$f_fstab" >> "/vz/root/${CTID}/etc/fstab"
        out=$(/usr/bin/jem storage setupUtils --ctid ${CTID})
        log $out
        OIFS=$IFS;IFS=$'\n'
        newDirs=($(echo -e "${f_fstab}" | awk '{print $2}'))
        IFS=$OIFS
        for d in "${newDirs[@]}" ; do
            vzexecRun "mkdir -p '$d';chmod 0777 '$d'"
        done
        vzexecRun "mount -a"
    }

    if [ ! -z "$f_akeys" ] ; then
        [ ! -d "/vz/root/${CTID}/root/.ssh" ] && mkdir -p "/vz/root/${CTID}/root/.ssh"
        echo -e "$f_akeys" > "/vz/root/${CTID}/root/.ssh/authorized_keys"
    fi

    if [ ! -z "$f_akeys2" ] ; then
        [ ! -d "/vz/root/${CTID}/root/.ssh" ] && mkdir -p "/vz/root/${CTID}/root/.ssh"
        echo -e "$f_akeys2" > "/vz/root/${CTID}/root/.ssh/authorized_keys2"
    fi
    chown root:root "/vz/root/${CTID}/root/" -R

    return 0
}
function doRouteAdd(){
    local requiredParqams=("CTID" "ROUTE_VIA" "ROUTE_NETWORK")
    local msg=$(checkParams ${requiredParqams[@]})
    [[ ! -z "${msg}" ]] && { writeJSONResponseErr "result=>4099" "message=>Missing param $msg" ; return 1; }
    if isContainerRunning $CTID ; then
        DOCKER_OSTEMPLATE=$(getOSTemplateType $CTID);
        vzexecSetCTID $CTID
	[ "x$DOCKER_OSTEMPLATE" == "xubuntu" ] && DOCKER_OSTEMPLATE='debian';
        [ "x$DOCKER_OSTEMPLATE" == "xfedora" ] && DOCKER_OSTEMPLATE='centos';

	isFunction add${DOCKER_OSTEMPLATE^}Route && { add${DOCKER_OSTEMPLATE^}Route && writeJSONResponseOut "result=>0" "message=>Route has been added succesfully" || writeJSONResponseErr "result=>4103" "message=>Could not add route!" ; return 1;} ;
    else
	writeJSONResponseErr "result=>4110" "message=>Can not execute command. Container is not running" ;
	return 1;
    fi
}

function doRouteDel(){
    local requiredParqams=("CTID")
    local msg=$(checkParams ${requiredParqams[@]})
    [[ ! -z "${msg}" ]] && { writeJSONResponseErr "result=>4099" "message=>Missing param $msg" ; return 1; }
    if isContainerRunning $CTID ; then
	DOCKER_OSTEMPLATE=$(getOSTemplateType $CTID) ;
        vzexecSetCTID $CTID ;
	[ "x$DOCKER_OSTEMPLATE" == "xubuntu" ] && DOCKER_OSTEMPLATE='debian';
        [ "x$DOCKER_OSTEMPLATE" == "xfedora" ] && DOCKER_OSTEMPLATE='centos';

	isFunction del${DOCKER_OSTEMPLATE^}Route && { del${DOCKER_OSTEMPLATE^}Route && writeJSONResponseOut "result=>0" "message=>Route has been deleted succesfully" || writeJSONResponseErr "result=>4104" "message=>Could not delete route!" ; return 1;} ;
    else
	writeJSONResponseErr "result=>4110" "message=>Can not execute command. Container is not running" ;
	return 1;
    fi
}

# init for openrc alpine

defineBigInline ALPINEINIT <<'EOF'
#!/sbin/runscript
description="Jelastic Daemon"
procname="jelinit"
pidfile="/var/run/lock/jelinit.lock"
stopsig="SIGTERM"

start() {
    ebegin "Starting mydaemon"
        /bin/bash /etc/init.d/jelinit start
    eend $?
}

stop() {
    ebegin "Stopping mydaemon"
        /etc/init.d/jelinit stop
    eend $?
}


EOF

defineBigInline DEBIANNETFIX <<'EOF'
#!/bin/bash
cmd=`ip a l  | sed -nre "/\s+inet\s/{s/.*\s([0-9]{1,3}.[0-9\.]{1,3}.[0-9]{1,3}.[0-9]{1,3}([\/0-9]{1,}))\sbrd.*(venet0:[0-9]{1,})/ip addr del \1 dev \3 \; /p}"`
eval "$cmd" 2>/dev/null

EOF

defineBigInline LOGROTATECONF <<'EOF'
/var/log/jem.log
/var/log/run.log {
    rotate 7
    copytruncate
    daily
    compress
    missingok
    notifempty
    size 50M
}

EOF


defineBigInline DOCKERINIT <<'EOF'
#!/bin/bash
#
# jelinit          Start/Stop the jelinit daemon.
#
# chkconfig: 2345 99 60
# description: jelinit
#
### BEGIN INIT INFO
# Provides:          jelinit
# Required-Start:    $local_fs $time $network $named
# Required-Stop:     $local_fs
# Default-Start:     2 3 4 5
# Default-Stop:      0 1 6
# Short-Description: Start/stop
#
# Description: The init script will start/stop
#              Then log (FATAL,ERROR,WARN,INFO and Notic)
### END INIT INFO
DOCKER_RUN_LOG="/var/log/run.log"
RUN_CMD="/.jelstart"
ENTRYPOINT_CMD="/.jelentry"
WORKINDIR_CMD="/.jelworkdir"
RUNSCRIPT=$( sed -e ':a;N;$!ba;s/\n/ /g' -e 's|\s*/bin/sh\s*-c\s*||' -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//' <<< cat $ENTRYPOINT_CMD $RUN_CMD  2>/dev/null )
dir=$(cat $WORKINDIR_CMD 2>/dev/null ) && cd ${dir:-/} 2>/dev/null;
SSHINIT="/etc/init.d/ssh"
JELINIT_LOCK="/var/run/lock/jelinit.lock"
JELINIT_FIRSTRUN="/run/lock/jelinit.firstrun"

[ -f /.jeluser ] && DOCKER_USER=$( cat /.jeluser )
[ ! -d /var/run/lock/ ] && mkdir -p /var/run/lock/ >/dev/null 2>/dev/null
log_end_msg(){
        echo "$1"
}
log_daemon_msg(){
        echo -n "$1"
}

SYSTEMCTL_SKIP_REDIRECT="true"
_SYSTEMCTL_SKIP_REDIRECT="true"

[ -f "/lib/lsb/init-functions" ] && . /lib/lsb/init-functions
[ -f "/.jelenv" ] &&  OLD_IFS=$IFS; IFS=$'\n'; for env in $(cat /.jelenv); do eval "export $(echo $env | sed -rne 's/"/\\"/g;s/([^=]+)=(.*)/\1="\2"/;p')"; done ; for env in $(cat /.jelenv); do eval "export $(echo $env | sed -rne 's/"/\\"/g;s/([^=]+)=(.*)/\1="\2"/;p')"; done ; IFS=$OLD_IFS

PATH="$PATH:/bin:/usr/bin:/sbin:/usr/sbin:/usr/local/sbin:/usr/local/bin"

runfile=$(awk '{print $1}' <<< $RUNSCRIPT );
[ ! -z "$runfile" -a -f "${runfile}" ] && { chmod a+x "${runfile}"; } || {
        runfile=$(which $runfile 2>/dev/null );
        [ ! -z "$runfile" -a -f "${runfile}" ] && { chmod a+x "${runfile}"; }
}

function patchenv(){
    temp_dirs="/run/apache2 /run/lock/apache2 /run/mysqld/" ;
    for temp_dir in $temp_dirs
    do
        mkdir -p $temp_dir;
        chmod 777 $temp_dir;
    done
}

ports="^(21|22|23|25|53|80|110|111|143|139|389|443|445|465|587|993|995|1433|1434|1521|1528|2424|2483|2484|3306|4447|5432|6262|8743|8009|27017|11211)$"


function rpss(){
        val=$(ss -tnlp 2>/dev/null | grep -v '127.0.0.'| sed -r -e '1d' -e 's/LISTEN[^:]+[:0-9a-z\.\*]{0,}:+//g' | cut -d' ' -f1 );
        echo "$val";
}

function rpnetstat(){
        val=$(netstat -tnlp 2>/dev/null| grep -v '127.0.0.'| sed -r -e '1,2d' -e 's/tcp[^:]+[:0-9a-z]{1,}:+//g'  | cut -d' ' -f1 )
        echo "$val";
}

function addIptablesRedirect(){
        local rPort=$1;
        [ ! -z "$rPort" ] && iptables -t nat -L 2>/dev/null | grep -qE "REDIRECT.*$rPort" || iptables -t nat -I PREROUTING -p tcp -m tcp --dport 80 -j REDIRECT      --to-ports $rPort -m comment --comment "Jelastic HTTP Autoredirect" 2>/dev/null;
}


function setRedirect(){
    tryresetcount=60
    priorityPorts="8080"
    local port
    count=100
    while [ $count -ge 0 ];
    do
        iptab=`which iptables` ; [ -z "$iptab" ] && sleep 1 || break
        count=$((count-1))
    done
    if [ ! -z "$JELASTIC_EXPOSE" ] ; then
        if [ ! -z "${JELASTIC_EXPOSE##*[!0-9]*}" ]; then
            if [ $JELASTIC_EXPOSE -ge 1 -a $JELASTIC_EXPOSE -le 65535 ]; then
                echo "add redirect to $JELASTIC_EXPOSE" >> ${ACTION_LOG} ;
                addIptablesRedirect "$JELASTIC_EXPOSE" ;
                return 0;
            fi
        fi
    fi
    [ ! -z $JELASTIC_PRIORITY_PORTS ] && priorityPorts="${priorityPorts}|${JELASTIC_PRIORITY_PORTS//\,/|}";
    [ ! -z "$J_TRYCOUNT" ] && tryresetcount=$J_TRYCOUNT
    eval "command -v netstat >/dev/null 2>&1 && get_ports=rpnetstat || get_ports=rpss";
    CURL_RUN="-sI -X GET -H 'HTTP/1.1' http://127.0.0.1:"
    ACTION_LOG="/var/log/jem.log"
    echo "JELASTIC_PRIORITY_PORTS=${priorityPorts%\|}" >> $ACTION_LOG
    while [ $tryresetcount -gt 0 ]
    do
        eval "command -v curl >/dev/null 2>>${ACTION_LOG} && CURL=$(command -v curl ) || CURL=''";
        S_REDIRECT_PORT=$( $get_ports );
        if grep -q -E "^80$" <<< "$S_REDIRECT_PORT"; then
            echo "port 80 detected" >>${ACTION_LOG}
            exit 0
        fi
        port=$( grep -E "^(${priorityPorts%\|})$" <<< "$S_REDIRECT_PORT" | sort -un | head -n1 )
        if [ ! -z "$port" ] ; then
            addIptablesRedirect "$port" ;
            exit 0;
        fi
        sleep 2;
        tryresetcount=$((tryresetcount-1))

    done

    tryresetcount=200
    while [ $tryresetcount -gt 0 ]
    do
        S_REDIRECT_PORT=$( $get_ports );

        for port in $( grep -v -E $ports <<< "$S_REDIRECT_PORT" | sort -un )
        do
            if [[ $CURL ]] ; then
                $CURL ${CURL_RUN}${port} >> ${ACTION_LOG} 2>&1
                result=$?
                if [ $result -eq 0 ] ; then
                    addIptablesRedirect "$port" ;
                    echo "port detected ${port} " >>${ACTION_LOG}
                    exit 0;
                fi
            else
                addIptablesRedirect "$port" ;
                echo "port detected ${port} " >>${ACTION_LOG}
                exit 0;
            fi
        done

        sleep 2
        tryresetcount=$((tryresetcount-1))
    done

}


start () {
    ACTION_LOG="/var/log/jem.log"
    [ -f "$JELINIT_FIRSTRUN" ] && {
        [ -f "$JELINIT_LOCK" ] && {
            rm -f $JELINIT_FIRSTRUN;
            exit 0;
        }
    }
    [ -f "$JELINIT_LOCK" ] && {
        echo "jelinit exists" >> ${ACTION_LOG}
        pid=$(cat "$JELINIT_LOCK")
        if [ ! -z "$pid" ] && [ -f /proc/$pid/cmdline ] && grep -q jelinit "/proc/$pid/cmdline" ; then return ; else rm  -f "$JELINIT_LOCK" ; fi
    }
    echo "$$"  > "$JELINIT_LOCK";
    patchenv
    [ -f "/sbin/ifconfig" -a ! -e "/bin/systemctl" ] && /sbin/ifconfig lo up;
    [ ! -f "${DOCKER_RUN_LOG}" ] &&  touch ${DOCKER_RUN_LOG} 2>/dev/null
    chmod a+w "${DOCKER_RUN_LOG}"  2>/dev/null

    [ -f "$SSHINIT" -o -L "$SSHINIT" ] && $SSHINIT start &
    [ ! -z "$RUNSCRIPT" ] && {
        homedir=$( getent passwd "${DOCKER_USER:-root}" | cut -d: -f6 )
        if [ -z "$DOCKER_USER" ] ; then
            export PATH="$PATH" && ( /bin/sh -c "cd ${dir:-/}; ${RUNSCRIPT}" >>${DOCKER_RUN_LOG} 2>>${DOCKER_RUN_LOG} & )
        else
    	    checkshell=$(readlink -f /bin/sh 2>/dev/null )
    	    jshell=''
	    [ "x$checkshell" == "x/bin/dash" ] && jshell="-s /bin/bash"
	    export PATH="$PATH" && ( su - ${DOCKER_USER} $jshell -c /bin/sh -c "cd ${dir:-/}; export HOME=${homedir}; ${RUNSCRIPT}" >>${DOCKER_RUN_LOG} 2>>${DOCKER_RUN_LOG} & )
        fi
        if [ "$JELASTIC_EXPOSE" == "0" -o "x${JELASTIC_EXPOSE^^}" == "xDISABLED" -o "x${JELASTIC_EXPOSE^^}" == "xFALSE" ]; then
            echo "Port autoredirect disabled : $JELASTIC_EXPOSE " >> ${ACTION_LOG}
	    if [ -n "$(iptables -L -n -t nat | grep 'Jelastic HTTP Autoredirect')" ]; then
	    	local TARGET_REDIRECT_PORT=$(iptables -L -t nat | grep 'Jelastic HTTP Autoredirect'| awk '{print $NF}');
	    	/sbin/iptables -t nat -D PREROUTING -p tcp -m tcp --dport 80 -j REDIRECT --to-ports ${TARGET_REDIRECT_PORT}  -m comment --comment "Jelastic HTTP Autoredirect"
	    fi
            return 0 ;
        else
            setRedirect &
        fi

    }

    return $?
}

stop () {
    rm -f $JELINIT_FIRSTRUN;
    [ ! -f "$JELINIT_LOCK" ] && return || rm "$JELINIT_LOCK";
}

case "$1" in
    start)
            log_daemon_msg "Starting jelinit"
            if start ; then
                    log_end_msg $?
            else
                    log_end_msg $?
            fi
            ;;
    stop)
            log_daemon_msg "Stopping jelinit"
            if stop ; then
                   log_end_msg $?
           else
                   log_end_msg $?
           fi
           ;;
    restart)
            log_daemon_msg "Restarting jelinit"
            stop
            if start ; then
                    log_end_msg $?
            else
                    log_end_msg $?
            fi
            ;;
    reload|force-reload)
            log_daemon_msg "Reloading jelinit"
            stop
            if start ; then
                    log_end_msg $?
            else
                    log_end_msg $?
            fi
            ;;
    status)
            exit 0
            ;;
    *)
        echo "Usage: /etc/init.d/$NAME {start|stop|restart|reload|force-reload|status}"
        exit 3
        ;;
esac

exit 0
EOF
