#!/bin/bash

# Copyright 2015 Jelastic, Inc.

# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at

# http://www.apache.org/licenses/LICENSE-2.0

# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.



DESCRIPTION="Firewall module";
VERSION="1.1";
DEFAULT_ACTION="Usage";

inherit tests os envinfo log net config vzexec;
include cartridge-common;

$PROGRAM 'iptables';
$PROGRAM 'find';
$PROGRAM 'xargs';
$PROGRAM 'netstat';
$PROGRAM 'rpcinfo'
$PROGRAM 'ip';
$PROGRAM 'sort';
$PROGRAM 'sed';
$PROGRAM 'grep';
$PROGRAM 'awk';
$PROGRAM 'iptables-restore';
$PROGRAM 'vzctl'

SAVEFILE='/var/lib/jelastic/firewall'
CUSTOM_RULES_FILE='/etc/sysconfig/iptables-custom'
JELASTIC_4RULES_FILE='/etc/sysconfig/iptables4-jelastic'
JELASTIC_6RULES_FILE='/etc/sysconfig/iptables6-jelastic'

# 7755 - file replication (lsync?)
# 7979 - for export/import
# 4000,5000,8743 - HA
DMZ_PORTS="4000,5000,7755,7979,8743";

declare PublicIP;
declare FTPPort;
declare RSLV_ADDR;
declare CORE_ADDR;
declare APP_ADDR;
declare DB_ADDR;
declare -a OPENPORTS;
declare -a CLOSEDPORTS;

declare -r ERR_NO_METADATA=4080;

function _getbalancerRedirPorts() { return 0; }
function _getapache_phpRedirPorts { return 0; }
function _getnginx_phpRedirPorts { return 0; }
function _getmavenRedirPorts { return 0; }
function _getnginx_rubyRedirPorts { return 0; }

function _getcartridgePorts() {
    #restoreEnvironmentVariables;
    echo $($SED -re 's/"//g'  <<<  $($SED -re 's/Private_Port=//g' <<< $(cat $MANIFEST_EXPORTED | $GREP "Private_Port=" ))| sort -u) ${FTPPort};
    return 0;
}

function _getcartridgeRedirPorts () {
    echo "PREROUTING:0.0.0.0/0:0.0.0.0/0:80:8080:REDIRECT";
    return 0;
}

function _getglassfishRedirPorts () {
    echo "PREROUTING:0.0.0.0/0:0.0.0.0/0:80:28080:REDIRECT PREROUTING:0.0.0.0/0:0.0.0.0/0:443:8743:REDIRECT OUTPUT:0.0.0.0/0:127.0.0.0/8:80:28080:REDIRECT";
    return 0;
}

function _defaultComputeNodeRedirPorts () {
    echo "PREROUTING:0.0.0.0/0:0.0.0.0/0:80:8080:REDIRECT PREROUTING:0.0.0.0/0:0.0.0.0/0:443:8743:REDIRECT OUTPUT:0.0.0.0/0:127.0.0.0/8:80:8080:REDIRECT";
    return 0;
}

function _getmysqlRedirPorts() { return 0; }
function _getpostgresRedirPorts() { return 0; }

function _isPublicIPv4() {
    getAddr "venet0" "ipv4"
    [[ "${#ipv4_list[@]}" -ne 0 ]] && {
        for ip in ${ipv4_list[@]} ; do
            [[ "${ip}" == "127.0.0.1" ]] && continue;
            isLANIP "$ip" || return 0;
        done;
    }
    return 1;
}


function __getAllIPs() {
    echo $($IP a l | $SED -rne '/inet/{s/.*inet6.* //;s/\/.*//;s/peer.*//;s/in.*\s+(.*)/\1/; /(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])/p}' | sort -u | $SED -re ':a;N;$!ba;s/\n/ /g;');
}

function getLANIPs() {
    local IPS=$(__getAllIPs);
    local res=();
    for ip in ${IPS[@]} ; do
        [[ "${ip}" == "127.0.0.1" ]] && continue;
        isLANIP "${ip}" && res=(${res} ${ip});
    done;
    echo "${res[@]}";
}

function isRange() {
    : ${1:?"Missing param: Port to test"};
    $GREP -qP "[-|:]" <<< $1;
    return $?;
}

function _setDefaultPolicy() {
    local policy=${1:-"DROP"};
    $IPTABLES -P INPUT ${policy};
    $IPTABLES -P FORWARD ${policy};
    $IPTABLES -P OUTPUT ACCEPT
}

function doUsage() {
    showUsageMessage
}

function onModLoadCallback() {
    log "Preload callback";
    local __closedports __openports

    #load ports lists from storage
    OPENPORTS=($(loadConfig "${SAVEFILE}" OPENPORTS))
    CLOSEDPORTS=($(loadConfig "${SAVEFILE}" CLOSEDPORTS))

    _isPublicIPv4 && PublicIP=$__TRUE || publicIP=$__FALSE;
    FTPPort=$($NETSTAT -tnlp | $SED -n -re '/ftp/{s/((\S+)\s+){3}(\S+)\s+((\S+)\s+)+/\3/;s/[^:]+:([0-9]+)/\1/;s/://g;p}');
    NFSPort=$($RPCINFO -p 2>/dev/null | $SED -n -re '/nfs/{s/\s+(\S+\s+)+([0-9]+)\s+nfs.*/\2/g;p}' | uniq | $SED -e ':a' -e 'N' -e '$!ba' -e 's/\n/ /g' | $SED -e 's/ /,/g' )
    RPCPort=$($RPCINFO -p 2>/dev/null | $SED -n -re '/portmapper/{s/\s+(\S+\s+)+([0-9]+)\s+.*/\2/g;p}' | uniq | $SED -e ':a' -e 'N' -e '$!ba' -e 's/\n/ /g' | $SED -e 's/ /,/g' )

    ## TODO: remove "params" garbarge option
    local temp=`getopt -l ctid:,rules:,cp:,op:,rp: -- params "$@" 2>/dev/null` oldifs;
    [[ $? != 0 ]] && die -q "Terminating...";
    eval set -- "$temp";

    while true ; do
        case "$1" in
            --cp)
                # ports to close
                [[ ! -z "$2" && -z "$($SED -rne '/[0-9]+/p' <<< $2)" ]] && { shift 1; break; }
                oldifs=$IFS;
                IFS=',';
                __closedports=(${2});
                IFS=${oldifs};
                shift 2;
                ;;
            --op)
                # ports to open
                [[ ! -z "$2" && -z "$($SED -rne '/[0-9]+/p' <<< $2)" ]] && { shift 1; break; }
                oldifs=$IFS;
                IFS=',';
                __openports=(${2});
                IFS=${oldifs};
                shift 2;
                ;;
            --rp)
                # ports to remove from open ports list
                [[ ! -z "$2" && -z "$($SED -rne '/[0-9]+/p' <<< $2)" ]] && { shift 1; break; }
                oldifs=$IFS;
                IFS=',';
                __removeports=(${2});
                IFS=${oldifs};
                shift 2;

                for i in "${__removeports[@]}" ; do
                    # remove the port to remove from stored list of open ports
                    OPENPORTS=($(removeValueFromArray "${OPENPORTS[*]}" "${i}"));
                done

                ;;
            --ctid)
                shift
                CTID=$1
                vzexecSetCTID $CTID
                shift
                ;;
            --rules)
                shift;
                oldifs=$IFS;
                IFS=';';
                RULES=($1);
                IFS=${oldifs};
                shift;
                ;;
            --)
                shift;
                break;
                ;;
        esac;
    done;

}

function describeStart() {
    echo "start firewall and load rules";
}

function describeStartParameters() {
    echo "--op [port1,[port2,[port3-port4]] --cp [port1,[port2,[port3-port4]] --rp [port1,[port2]]";
}

function describeStartOptions() {
    echo "op: open port(s) list. A list of ports which have an 'ACCEPT' policy";
    echo "cp: closed port(s) list. A list of ports which have a 'DROP' policy";
    echo "rp: ports to remove from existing 'open' ports";
}

function doStart() {
    declare -a ports;
    log "Starting firewall";

    local cartridge_config="/opt/repo/jelastic/jelastic.conf";
    [ -f "$cartridge_config"  ] && Firewall_Enabled=$($GREP Firewall_Enabled "$cartridge_config" | $AWK -F "=" '{ print $2 }')
    [ ! -z "${Firewall_Enabled}" ] && FIREWALL_ENABLED=${Firewall_Enabled};  ### Override for cartridges
    [[ "${FIREWALL_ENABLED}" -eq "0" ]] || [ -z "${FIREWALL_ENABLED+xxx}" ] || [ -z "${FIREWALL_ENABLED}" -a "${FIREWALL_ENABLED+xxx}" = "xxx" ] && return 0;
    [[ "${COMPUTE_TYPE}" == 'memcached' ]] && return 0;  # memcache has own firewall

    $IPTABLES -F;
    $IPTABLES -t nat -F;
    _setDefaultPolicy;

    $IPTABLES -A INPUT -i lo -j ACCEPT;
    $IPTABLES -A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT;

    #exports
    NFSIPS=()
    [ -e '/etc/exports' ] && NFSIPS=($($SED -re 's/.+(\s|\t)+(([0-9]+\.){3}[0-9]+(\/[0-9]{0,2})?).*/\2/g' -e '/#/d' '/etc/exports' | sort | uniq | $SED -e ':a' -e 'N' -e '$!ba' -e 's/\n/ /g'))

    # for internal services:
    intips=($(getLANIPs));
    for ip in ${intips[@]} ; do
        $IPTABLES -A INPUT -p tcp -m multiport --dports ${DMZ_PORTS} -d ${ip} -j ACCEPT;
        $IPTABLES -A INPUT -p udp -m multiport --dports ${DMZ_PORTS} -d ${ip} -j ACCEPT;
        if [[ "${#NFSPort}" -gt 0 ]] ; then
            for nfsip in ${NFSIPS[@]} ; do
                $IPTABLES -A INPUT -p tcp -m multiport --dports $NFSPort -d $ip -s $nfsip -j ACCEPT;
                $IPTABLES -A INPUT -p udp -m multiport --dports $NFSPort -d $ip -s $nfsip -j ACCEPT;
            done
        fi
        if [[ "${#RPCPort}" -gt 0 ]] ; then
            for rpcip in ${NFSIPS[@]} ; do
                $IPTABLES -A INPUT -p tcp -m multiport --dports $RPCPort -d $ip -s $rpcip -j ACCEPT;
                $IPTABLES -A INPUT -p udp -m multiport --dports $RPCPort -d $ip -s $rpcip -j ACCEPT;
            done
        fi
    done;

    $IPTABLES -A INPUT -m state --state NEW -s 10.0.0.0/27 -j ACCEPT;

    log "getting Infra adresses";
    getInfraAddresses infraAddr;

    isValidIP ${CORE_ADDR} && {
        $IPTABLES -A INPUT -m state --state NEW -s ${CORE_ADDR} -m tcp -p tcp --dport 22 -j ACCEPT;
    } || {
        $IPTABLES -A INPUT -m state --state NEW -s 0.0.0.0/0 -m tcp -p tcp --dport 22 -j ACCEPT;
    }

    for jaddr in ${JEL_CORE_ADDR}; do
        isValidIP ${jaddr} && {
            $IPTABLES -A INPUT -m state --state NEW -s ${jaddr} -m tcp -p tcp --dport 22 -j ACCEPT;
        }
    done

    for gaddr in ${GATE_ADDR}; do
        isValidIP ${gaddr} && {
            $IPTABLES -A INPUT -m state --state NEW -s ${gaddr} -m tcp -p tcp --dport 22 -j ACCEPT;
        }
    done

    [ ! -z "${CORE1_ADDR}" ] && isValidIP ${CORE1_ADDR} && $IPTABLES -A INPUT -m state --state NEW -s ${CORE1_ADDR} -m tcp -p tcp --dport 22 -j ACCEPT;
    [ ! -z "${CORE2_ADDR}" ] && isValidIP ${CORE2_ADDR} && $IPTABLES -A INPUT -m state --state NEW -s ${CORE2_ADDR} -m tcp -p tcp --dport 22 -j ACCEPT;

    redirPorts=($(isFunction _get$($SED -re 's/-/_/g' <<< ${COMPUTE_TYPE})RedirPorts && { _get$($SED -re 's/-/_/g' <<< ${COMPUTE_TYPE})RedirPorts; } || _defaultComputeNodeRedirPorts));

    # process input chain NAT
    for port in ${redirPorts[@]} ; do
        local ruleParams=($($SED 's/:/ /g' <<< ${port}));
        $IPTABLES -t nat -A ${ruleParams[0]} -s ${ruleParams[1]} -d ${ruleParams[2]} -m tcp -p tcp --dport ${ruleParams[3]} -j ${ruleParams[5]} --to-port ${ruleParams[4]};
    done;

    [ ${COMPUTE_TYPE} == "cartridge" ] && {
        [ -f "${CARTRIDGE_HOME}/jelastic/scripts/firewall.sh" ] && source "${CARTRIDGE_HOME}/jelastic/scripts/firewall.sh" >>$JEM_CALLS_LOG 2>&1;
    }

    [ -f "${CUSTOM_RULES_FILE}" ] && { $IPTABLES_RESTORE -n < "${CUSTOM_RULES_FILE}" 2>>$ACTIONS_LOG ;
        echo "CUSTOM RULES FILE CONTENT"  >> $JEM_CALLS_LOG; cat "${CUSTOM_RULES_FILE}" >> $JEM_CALLS_LOG ;
    }

    [ -f "${JELASTIC_4RULES_FILE}" ] && { $IPTABLES_RESTORE -n < "${JELASTIC_4RULES_FILE}" 2>>$ACTIONS_LOG ;
        echo "JELASTIC RULES FILE CONTENT"  >> $JEM_CALLS_LOG; cat "${JELASTIC_4RULES_FILE}" >> $JEM_CALLS_LOG ;
    }

    [ -f "${JELASTIC_6RULES_FILE}" ] && { $IPTABLES_RESTORE -n < "${JELASTIC_6RULES_FILE}" 2>>$ACTIONS_LOG ;
        echo "JELASTIC RULES FILE CONTENT"  >> $JEM_CALLS_LOG; cat "${JELASTIC_6RULES_FILE}" >> $JEM_CALLS_LOG ;
    }

    $IPTABLES -A INPUT -j REJECT --reject-with icmp-host-prohibited;
    log "saving rules";
    /sbin/service iptables save 2>/dev/null | $GRAB_OUTPUT;
    return 0;
}

function describeFWStart() {
    echo "Alias for Start";
}

function describeList() {
    echo "List firewall rules";
}

function doList() {
    $IPTABLES -L -t $@
}

function doFWStart() {
    local resultMsg;
    declare -i result;
    log "FWSTART configuring firewall";
    resultMsg=$(doStart); result=$?;
    [[ "${result}" -eq "0" ]] && writeJSONResponseOut "result=>${result}" "message=>Firewall has been started" || writeJSONResponseErr "result=>${result}" "message=>${resultMsg}";
    return ${result};
}

function describeStop() {
    echo "clear all rules and stop firewall";
}

function doStop() {
    [[ "${FIREWALL_ENABLED}" -eq "0" ]] || [ -z "${FIREWALL_ENABLED+xxx}" ] || [ -z "${FIREWALL_ENABLED}" -a "${FIREWALL_ENABLED+xxx}" = "xxx" ] && return 0;
    $IPTABLES -X;
    $IPTABLES -X -t nat;
    $IPTABLES -F;
    $IPTABLES -F -t nat;
    _setDefaultPolicy "ACCEPT";
    return 0;
}

function describeFWStop() {
    echo "Alias for Stop";
}

function doFWStop() {
    local resultMsg;
    declare -i result;
    resultMsg=$(doStop); result=$?;
    [[ "${result}" ]] && writeJSONResponseOut "result=>${result}" "message=>Firewall has been stopped" || writeJSONResponseErr "result=>${result}" "message=>${resultMsg}";
}

function _isFWEnabled() {
    local status=$($SED -rne '/FIREWALL_ENABLED/{s/FIREWALL_ENABLED=([0-1]){1}/\1/;p}' ${META_FILE});
    local cartridge_config="/opt/repo/jelastic/jelastic.conf";
    [ -f "$cartridge_config"  ] && status=$($GREP Firewall_Enabled "$cartridge_config" | $AWK -F "=" '{ print $2 }');
    [ -z "${status}" ] && status="1";
    [[ "${status}" -eq "1" ]] && return 0;
    return 1;
}

function doisEnabled() {
    _isFWEnabled
}

function describeFWStatus() {
    echo "displays firewall status";
}

function doFWStatus() {
    local param=${1};

    [[ -z ${param} ]] && {
        _isFWEnabled && writeJSONResponseOut "result=>0" "message=>Firewall enabled" || writeJSONResponseOut "result=>0" "message=>Firewall disabled";
        return 0;
    }

    message=$($IPTABLES -vnL INPUT | $SED -re '/INPUT/d;/target/d;s/\s*((\S+)\s+){8}(\S+)\s+(.*)/\4/g' | $SED -rne '/^\s*$/d;/:/{s/.*dpt(s)?:([0-9]+)(:)?([0-9]+)?.*/\2:\4/;p}' | $SED -re ':a;N;$!ba;s/\n/,/g;s/:,/,/g;s/:$//g');
    message="Open ports: ${message}";
    writeJSONResponseOut "result=>0" "message=>${message}";
    return 0;
}

function describeFWReconfigure() {
    echo "reconfigure firewall";
}

function describeFWReconfigureParameters() {
    describeStartParameters
}

function describeFWReconfigureOptions() {
    describeStartOptions
}


function doFWReconfigure() {
    _isFWEnabled && doStart;
}

function describeEnable() {
    echo "enable firewall";
}

function describeEnableParameters() {
   describeStartParameters
}

function describeEnableOptions() {
    describeStartOptions
}

function doEnable() {
    if $GREP -q "FIREWALL_ENABLED" ${META_FILE} ; then
        $SED -i -re "s/FIREWALL_ENABLED=([0-9]+)/FIREWALL_ENABLED=1/g" ${META_FILE}
    else
        echo -e "\nFIREWALL_ENABLED=1" >> ${META_FILE}
        $SED -i -re '/^$/d' ${META_FILE}
    fi
    chkconfig --level 345 iptables on 2>&1 | $GRAB_OUTPUT
    echo "Firewall enabled"
    return 0
}

function describeFWEnable() {
    echo "Alias for Enable";
}

function doFWEnable() {
    local resultMsg;
    declare -i result;
    resultMsg=$(doEnable); result=$?;
    [[ "${result}" ]] && writeJSONResponseOut "result=>${result}" "message=>Firewall has been enabled" || writeJSONResponseErr "result=>${result}" "message=>${resultMsg}";
}

function describeDisable() {
    echo "disable firewall";
}

function doDisable() {
    [[ -n "${META_FILE}" ]] && [[ -e "${META_FILE}" ]] && {
        if $GREP -q "FIREWALL_ENABLED" ${META_FILE} ; then
            $SED -i -re "s/FIREWALL_ENABLED=([0-9]+)/FIREWALL_ENABLED=0/g" ${META_FILE};
        fi;
        chkconfig iptables off 2>&1 | $GRAB_OUTPUT;
        echo "Firewall disabled";
        _setDefaultPolicy "ACCEPT";
        $IPTABLES -F INPUT; service iptables save &> /dev/null;
        return 0;
    } || {
        echo "Error: No metadata found!";
        return ${ERR_NO_METADATA};
    }
}

function describeDisable() {
    echo "Alias for Disable";
}

function doFWDisable() {
    local resultMsg;
    declare -i result;
    resultMsg=$(doDisable); result=$?;
    [[ "${result}" ]] && writeJSONResponseOut "result=>${result}" "message=>Firewall has been disabled" || writeJSONResponseErr "result=>${result}" "message=>${resultMsg}";
}

function describePanic() {
    echo "clear all rules and set default policy to DROP";
}

function doPanic() {
    [[ "${FIREWALL_ENABLED}" -eq "0" ]] || [ -z "${FIREWALL_ENABLED+xxx}" ] || [ -z "${FIREWALL_ENABLED}" -a "${FIREWALL_ENABLED+xxx}" = "xxx" ] && return 0;
    $IPTABLES -X;
    $IPTABLES -X -t nat;
    $IPTABLES -F;
    $IPTABLES -F -t nat;
    _setDefaultPolicy "DROP";
    return 0;
}


function dofwset() {
    echo "*filter" > "/vz/root/${CTID}${JELASTIC_4RULES_FILE}"
    for ruleraw in ${RULES[@]} ; do
        rulevars=$(awk -F, '{print "proto="$1";ptype="$2";dport="$3";srchost="$4";dsthost="$5";chain="$6";raction="$7";tcptype="$8";"}' <<< $ruleraw )
        eval $rulevars
        chain="${chain^^}"
        proto="${proto,,}"

        rulecmd="-A $chain"
        if [ "x$proto" != "x" ] ; then
            if [ "x$dport" != "x" ] ; then
                rulecmd="$rulecmd -p $proto"
            fi
        fi

        if [ "x$srchost" != "x" ] ; then
            rulecmd="$rulecmd -s $srchost"
        fi

        if [ "x$dsthost" != "x" ] ; then
            rulecmd="$rulecmd -s $dsthost"
        fi

        if [ "x$ptype" == "xrange" ] ; then
            if [ "x$dport" != "x" ] ; then
                rulecmd="$rulecmd -m multiport --dports $dport"
            fi
        else
            if [ "x$dport" != "x" ] ; then
                rulecmd="$rulecmd --dport $dport"
            fi
        fi

        rulecmd="$rulecmd -j $raction"
        if [ "x$tcptype" == "xIPV4" ] ; then
            echo $rulecmd >> "/vz/root/${CTID}${JELASTIC_4RULES_FILE}"
        else
            echo $rulecmd >> "/vz/root/${CTID}${JELASTIC_6RULES_FILE}"
        fi

        echo "CTID $CTID RULE $rulecmd" >> ${JEM_CALLS_LOG} 2>&1;
    done
    echo "COMMIT" >> "/vz/root/${CTID}${JELASTIC_4RULES_FILE}"
    vzexecRun "jem firewall start"
    writeJSONResponseOut "result=>0" "message=>Firewall rules set" "log=>$(vzexecGetLastStdOut) $(vzexecGetLastStdErr)"
    return 0
}
